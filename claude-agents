#!/usr/bin/env python3
"""
claude-agents — live terminal dashboard for Claude Code sessions & agents.
btop-style TUI with rounded box panels, braille sparklines, and tree views.
Run in a separate pane: claude-agents
"""

import argparse
import curses
import glob
import random
import json
import os
import sqlite3
import subprocess
import sys
import time
from datetime import datetime, timezone

VERSION = "0.7.0"

PREVIEW_ROWS = 7  # lines reserved for inline preview (divider + header + content)

DB_PATH = os.environ.get("CLAUDE_AGENTS_DB") or os.path.expanduser("~/.claude/ccnotify/ccnotify.db")

MAX_COMPLETED_AGENTS = 10
MAX_HISTORY = 20
MAX_TOOL_EVENTS = 3  # tools shown per agentless session

# ── CONSTANTS & SYMBOLS ──────────────────────────────────────

SYMBOLS = {"tl": "╭", "tr": "╮", "bl": "╰", "br": "╯", "h": "─", "v": "│", "lt": "├", "rt": "┤"}
BRAILLE = "⠀⠂⠄⠆⠈⠐⠒⠔⠖⠘⠠⠢⠤⠦⠨⠰⠲⠴⠶⠸⡀⡂⡄⡆⡈"

GREEN = CYAN = YELLOW = DIM = MAGENTA = WHITE = RED = 0
# Selection highlight variants (white-on-dark-gray)
SEL = SEL_DIM = SEL_CYAN = SEL_YELLOW = SEL_GREEN = SEL_MAGENTA = 0
BG_SEL = 236  # dark gray background


def init_colors():
    global GREEN, CYAN, YELLOW, DIM, MAGENTA, WHITE, RED
    global SEL, SEL_DIM, SEL_CYAN, SEL_YELLOW, SEL_GREEN, SEL_MAGENTA, BG_SEL
    curses.start_color()
    curses.use_default_colors()
    # Normal colors (pair 1-7)
    for i, c in enumerate([curses.COLOR_GREEN, curses.COLOR_WHITE, curses.COLOR_CYAN,
                           curses.COLOR_YELLOW, 8, curses.COLOR_MAGENTA, curses.COLOR_RED], 1):
        curses.init_pair(i, c, -1)
    GREEN = curses.color_pair(1) | curses.A_BOLD
    WHITE = curses.color_pair(2)
    CYAN = curses.color_pair(3) | curses.A_BOLD
    YELLOW = curses.color_pair(4) | curses.A_BOLD
    DIM = curses.color_pair(5)
    MAGENTA = curses.color_pair(6) | curses.A_BOLD
    RED = curses.color_pair(7) | curses.A_BOLD
    # Selection highlight colors (pair 11-16: foreground on dark gray)
    try:
        curses.init_pair(11, curses.COLOR_WHITE, BG_SEL)
        curses.init_pair(12, 8, BG_SEL)  # dim on dark gray
        curses.init_pair(13, curses.COLOR_CYAN, BG_SEL)
        curses.init_pair(14, curses.COLOR_YELLOW, BG_SEL)
        curses.init_pair(15, curses.COLOR_GREEN, BG_SEL)
        curses.init_pair(16, curses.COLOR_MAGENTA, BG_SEL)
        SEL = curses.color_pair(11) | curses.A_BOLD
        SEL_DIM = curses.color_pair(12)
        SEL_CYAN = curses.color_pair(13) | curses.A_BOLD
        SEL_YELLOW = curses.color_pair(14) | curses.A_BOLD
        SEL_GREEN = curses.color_pair(15) | curses.A_BOLD
        SEL_MAGENTA = curses.color_pair(16) | curses.A_BOLD
    except curses.error:
        # Fallback if terminal doesn't support 256 colors
        SEL = curses.A_REVERSE | curses.A_BOLD
        SEL_DIM = curses.A_REVERSE
        SEL_CYAN = curses.A_REVERSE | curses.A_BOLD
        SEL_YELLOW = curses.A_REVERSE | curses.A_BOLD
        SEL_GREEN = curses.A_REVERSE | curses.A_BOLD
        SEL_MAGENTA = curses.A_REVERSE | curses.A_BOLD


# ── DATA QUERIES ─────────────────────────────────────────────

STATS_RANGES = [
    ("1h", "-1 hours"),
    ("1d", "-1 days"),
    ("7d", "-7 days"),
    ("30d", "-30 days"),
    ("all", None),
]


def query_db(db_path: str, stats_range_idx: int = 2) -> dict:
    data = {
        "active_sessions": [],
        "running_agents": [],
        "completed_agents": [],
        "recent_prompts": [],
        "tool_events": {},  # session_id -> [{tool_name, tool_label}]
        "session_tools": {},  # session_id -> [{tool_name, tool_label, created_at}] — extended list for detail view
        "top_agents": [],
        "top_tools": [],
        "activity": {},
    }
    if not os.path.exists(db_path):
        return data

    try:
        conn = sqlite3.connect(db_path)
        conn.row_factory = sqlite3.Row

        # Active sessions: latest prompt per session.
        # A session is "active" if un-stopped AND one of:
        #   - created within the last 5 min (grace period before first tool call)
        #   - waiting for user input within the last 30 min (time-bounded to avoid forever-stuck sessions)
        #   - had tool activity in the last 10 min (actively running)
        # This correctly hides sessions killed without Stop firing.
        for row in conn.execute(
            """SELECT p.session_id, p.prompt, p.cwd, p.created_at, p.seq, p.lastWaitUserAt
               FROM prompt p
               INNER JOIN (
                   SELECT session_id, MAX(id) as max_id
                   FROM prompt
                   WHERE stoped_at IS NULL
                     AND (
                       created_at > datetime('now', '-5 minutes')
                       OR (lastWaitUserAt IS NOT NULL AND lastWaitUserAt > datetime('now', '-30 minutes'))
                       OR session_id IN (
                         SELECT DISTINCT session_id FROM tool_event
                         WHERE created_at > datetime('now', '-10 minutes')
                       )
                     )
                   GROUP BY session_id
               ) latest ON p.id = latest.max_id
               ORDER BY p.created_at DESC
               LIMIT 10"""
        ):
            data["active_sessions"].append(dict(row))

        # Running agents (skip ghosts with empty type)
        for row in conn.execute(
            """SELECT agent_id, agent_type, session_id, cwd, started_at, transcript_path
               FROM agent
               WHERE stopped_at IS NULL
               ORDER BY started_at ASC"""
        ):
            data["running_agents"].append(dict(row))

        # Completed agents (skip ghosts)
        for row in conn.execute(
            f"""SELECT agent_id, agent_type, session_id, cwd, started_at, stopped_at, transcript_path
                FROM agent
                WHERE stopped_at IS NOT NULL
                ORDER BY stopped_at DESC
                LIMIT {MAX_COMPLETED_AGENTS}"""
        ):
            data["completed_agents"].append(dict(row))

        # Recent completed prompts (skip system/task-notification noise)
        for row in conn.execute(
            f"""SELECT session_id, prompt, cwd, created_at, stoped_at, seq
                FROM prompt
                WHERE stoped_at IS NOT NULL
                  AND prompt NOT LIKE '<%'
                ORDER BY stoped_at DESC
                LIMIT {MAX_HISTORY}"""
        ):
            data["recent_prompts"].append(dict(row))

        # Tool events: last N per active session, within last 10 min
        active_sids = [s["session_id"] for s in data["active_sessions"]]
        for sid in active_sids:
            tools = []
            for row in conn.execute(
                """SELECT tool_name, tool_label FROM tool_event
                   WHERE session_id = ?
                     AND created_at > datetime('now', '-10 minutes')
                   ORDER BY created_at DESC
                   LIMIT ?""",
                (sid, MAX_TOOL_EVENTS),
            ):
                tools.append(dict(row))
            if tools:
                # Reverse so oldest is first (left-to-right reading)
                data["tool_events"][sid] = list(reversed(tools))

        # Session tools: extended tool list per active session (for DETAIL view)
        for sid in active_sids:
            try:
                rows = []
                for row in conn.execute(
                    """SELECT tool_name, tool_label, created_at FROM tool_event
                       WHERE session_id = ?
                         AND created_at > datetime('now', '-30 minutes')
                       ORDER BY created_at DESC
                       LIMIT 20""",
                    (sid,),
                ):
                    rows.append(dict(row))
                if rows:
                    data["session_tools"][sid] = list(reversed(rows))
            except sqlite3.OperationalError:
                pass

        # Activity buckets for sparklines (last 60s, 20 buckets of 3s each)
        for sid in active_sids:
            try:
                rows = conn.execute(
                    "SELECT created_at FROM tool_event WHERE session_id = ? AND created_at > datetime('now', '-60 seconds')",
                    (sid,)).fetchall()
                buckets = [0] * 20
                now_utc = datetime.now(timezone.utc)
                for (ts_str,) in rows:
                    try:
                        ts = datetime.fromisoformat(ts_str).replace(tzinfo=timezone.utc)
                        age = (now_utc - ts).total_seconds()
                        slot = int(age / 3)
                        if 0 <= slot < 20:
                            buckets[19 - slot] += 1
                    except Exception:
                        pass
                data["activity"][sid] = buckets
            except Exception:
                pass

        # Usage stats: top agent types + top tools
        _, sql_interval = STATS_RANGES[stats_range_idx]
        if sql_interval:
            agent_where = f"WHERE started_at > datetime('now', '{sql_interval}') AND agent_type != ''"
            tool_where = f"WHERE te.created_at > datetime('now', '{sql_interval}')"
        else:
            agent_where = "WHERE agent_type != ''"
            tool_where = ""
        try:
            data["top_agents"] = [
                dict(r) for r in conn.execute(
                    f"""SELECT agent_type, cwd, COUNT(*) as cnt FROM agent
                       {agent_where}
                       GROUP BY agent_type, cwd ORDER BY cnt DESC LIMIT 12"""
                )
            ]
        except sqlite3.OperationalError:
            data["top_agents"] = []
        try:
            data["top_tools"] = [
                dict(r) for r in conn.execute(
                    f"""SELECT te.tool_name, p.cwd, COUNT(*) as cnt
                       FROM tool_event te
                       LEFT JOIN prompt p ON te.session_id = p.session_id
                       {tool_where}
                       GROUP BY te.tool_name, p.cwd ORDER BY cnt DESC LIMIT 12"""
                )
            ]
        except sqlite3.OperationalError:
            data["top_tools"] = []

        conn.close()
    except sqlite3.OperationalError:
        pass

    return data


def read_team_tasks(team_name: str) -> list[dict]:
    """Read task JSON files from ~/.claude/tasks/{team_name}/."""
    tasks_dir = os.path.expanduser(f"~/.claude/tasks/{team_name}")
    if not os.path.isdir(tasks_dir):
        return []
    tasks = []
    try:
        for path in glob.glob(os.path.join(tasks_dir, "*.json")):
            try:
                with open(path, "r", errors="replace") as f:
                    obj = json.load(f)
                if isinstance(obj, dict) and "status" in obj and "subject" in obj:
                    tasks.append(obj)
                elif isinstance(obj, list):
                    # Some implementations store all tasks in one file
                    for item in obj:
                        if isinstance(item, dict) and "status" in item and "subject" in item:
                            tasks.append(item)
            except Exception:
                pass
    except Exception:
        pass
    return tasks


def query_teams(db_path: str, active_session_ids: set[str]) -> dict:
    """Read team config files + task files; supplement with team_session DB table."""
    result: dict = {"teams": [], "team_session_ids": set()}
    teams_root = os.path.expanduser("~/.claude/teams")
    team_map: dict[str, dict] = {}  # team_name -> {name, members, tasks}

    # 1. Read file-system team configs
    if os.path.isdir(teams_root):
        for config_path in glob.glob(os.path.join(teams_root, "*/config.json")):
            try:
                with open(config_path, "r", errors="replace") as f:
                    cfg = json.load(f)
                team_name = cfg.get("name") or os.path.basename(os.path.dirname(config_path))
                members = []
                for m in cfg.get("members", []):
                    agent_id = m.get("agentId", "")
                    if agent_id:
                        members.append({
                            "session_id": agent_id,
                            "teammate_name": m.get("name", ""),
                            "agent_type": m.get("agentType", ""),
                        })
                        result["team_session_ids"].add(agent_id)
                tasks = read_team_tasks(team_name)
                team_map[team_name] = {"name": team_name, "members": members, "tasks": tasks}
            except Exception:
                pass

    # 2. Supplement with team_session DB table (catches teammates not yet in config files)
    if os.path.exists(db_path):
        try:
            conn = sqlite3.connect(db_path)
            conn.row_factory = sqlite3.Row
            for row in conn.execute("SELECT session_id, team_name, teammate_name FROM team_session"):
                sid, tname, mname = row["session_id"], row["team_name"], row["teammate_name"]
                result["team_session_ids"].add(sid)
                if tname not in team_map:
                    team_map[tname] = {"name": tname, "members": [], "tasks": []}
                # Only add member if not already in list
                existing = {m["session_id"] for m in team_map[tname]["members"]}
                if sid not in existing:
                    team_map[tname]["members"].append({
                        "session_id": sid,
                        "teammate_name": mname,
                        "agent_type": "",
                    })
            conn.close()
        except Exception:
            pass

    # 3. Filter to only teams that have at least one member active
    for team in team_map.values():
        active_members = [m for m in team["members"] if m["session_id"] in active_session_ids]
        if active_members:
            team["members"] = active_members
            result["teams"].append(team)

    return result


# ── FORMATTERS ───────────────────────────────────────────────

def dir_tag(cwd: str) -> str:
    """Return a short [dirname] prefix from a cwd path."""
    if not cwd:
        return ""
    name = os.path.basename(cwd.rstrip("/")) or os.path.basename(os.path.dirname(cwd))
    return f"[{name}]" if name else ""


def find_transcript(agent_id: str) -> str:
    uid = os.getuid()
    for pattern in [
        f"/private/tmp/claude-{uid}/**/tasks/*{agent_id}*.output",
        f"/tmp/claude-{uid}/**/tasks/*{agent_id}*.output",
        os.path.expanduser(f"~/.claude/projects/**/*{agent_id}*.jsonl"),
        os.path.expanduser(f"~/.claude/**/*{agent_id}*.jsonl"),
    ]:
        try:
            matches = glob.glob(pattern, recursive=True)
            if matches:
                return sorted(matches, key=os.path.getmtime, reverse=True)[0]
        except Exception:
            pass
    return ""


_JSONL_FMT = (
    "python3 -u -c \""
    "import sys,json\n"
    "for line in sys.stdin:\n"
    "  try:\n"
    "    e=json.loads(line)\n"
    "    t=e.get('type','')\n"
    "    if t=='assistant':\n"
    "      c=e.get('message',e).get('content',e.get('content',''))\n"
    "      if isinstance(c,list):\n"
    "        txt=''.join(b.get('text','') for b in c if b.get('type')=='text')\n"
    "      else:\n"
    "        txt=str(c)\n"
    "      if txt.strip(): print(txt,flush=True)\n"
    "    elif t=='tool_use':\n"
    "      print(f\\\"  [{e.get('name','')}]\\\",flush=True)\n"
    "  except:pass\n"
    "\""
)


def read_preview_lines(agent: dict, n: int) -> list[str]:
    """Return the last n displayable lines from an agent's output file."""
    transcript = agent.get("transcript_path") or ""
    if not transcript or not os.path.exists(transcript):
        transcript = find_transcript(agent["agent_id"])
    if not transcript or not os.path.exists(transcript):
        return ["(no output yet)"]
    try:
        with open(transcript, "r", errors="replace") as f:
            raw = f.read()
        if transcript.endswith(".jsonl"):
            lines: list[str] = []
            for line in raw.splitlines():
                try:
                    e = json.loads(line)
                    t = e.get("type", "")
                    if t == "assistant":
                        c = e.get("message", e).get("content", e.get("content", ""))
                        txt = "".join(b.get("text", "") for b in c if b.get("type") == "text") if isinstance(c, list) else str(c)
                        lines.extend(ln for ln in txt.splitlines() if ln.strip())
                    elif t == "tool_use":
                        lines.append(f"[{e.get('name', '?')}]")
                except Exception:
                    pass
        else:
            lines = [ln for ln in raw.splitlines() if ln.strip()]
        return lines[-n:] if lines else ["(no output yet)"]
    except Exception as exc:
        return [f"(read error: {exc})"]


def open_agent_in_iterm2(agent: dict) -> str:
    transcript = agent.get("transcript_path") or ""
    if not transcript or not os.path.exists(transcript):
        transcript = find_transcript(agent["agent_id"])
    if not transcript or not os.path.exists(transcript):
        return "no transcript found"

    if transcript.endswith(".jsonl"):
        tail_cmd = f"tail -f '{transcript}' | {_JSONL_FMT}"
    else:
        tail_cmd = f"tail -f '{transcript}'"

    script = f"""tell application "iTerm2"
  tell current window
    create tab with default profile
    tell current session of current tab
      write text "{tail_cmd}"
    end tell
  end tell
end tell"""
    r = subprocess.run(["osascript", "-e", script], capture_output=True, text=True)
    return f"iTerm2: {r.stderr.strip()[:60]}" if r.returncode != 0 else ""



def fmt_dur(start_str: str, end_str: str | None = None) -> str:
    try:
        start = datetime.fromisoformat(start_str).replace(tzinfo=timezone.utc)
        end = datetime.fromisoformat(end_str).replace(tzinfo=timezone.utc) if end_str else datetime.now(timezone.utc)
        secs = max(0, int((end - start).total_seconds()))
        if secs < 60:
            return f"{secs}s"
        m, s = divmod(secs, 60)
        if m < 60:
            return f"{m}m{s:02d}s"
        h, m = divmod(m, 60)
        return f"{h}h{m:02d}m"
    except Exception:
        return "?"


def fmt_time(ts: str | None) -> str:
    if not ts:
        return ""
    try:
        return datetime.fromisoformat(ts).strftime("%H:%M:%S")
    except Exception:
        return "?"


def short_id(s: str) -> str:
    return s[:7] if len(s) > 8 else s


def short_session(s: str) -> str:
    return s[:6] if len(s) > 8 else s


def short_prompt(p: str | None, maxlen: int = 40) -> str:
    if not p:
        return ""
    p = p.replace("\n", " ").strip()
    if p.startswith("<"):
        return ""
    return p[:maxlen] + ".." if len(p) > maxlen else p


def safe_add(stdscr, row: int, col: int, text: str, width: int, attr=0):
    try:
        stdscr.addnstr(row, col, text, max(0, width - col), attr)
    except curses.error:
        pass


# ── BRAILLE GRAPH ────────────────────────────────────────────

def sparkline(buckets, width=10):
    n = width * 2
    vals = ([0] * max(0, n - len(buckets)) + buckets)[-n:]
    mx = max(vals) if vals else 0
    if mx == 0:
        return BRAILLE[0] * width
    norm = [min(4, int(v / mx * 4.99)) if v > 0 else 0 for v in vals]
    return "".join(BRAILLE[norm[i] * 5 + norm[i + 1]] for i in range(0, n, 2))


# ── GAME OF LIFE ─────────────────────────────────────────────

def life_init(rows, cols, density=0.3):
    """Random seed for Game of Life grid."""
    return [[random.random() < density for _ in range(cols)] for _ in range(rows)]


def life_step(grid, rows, cols):
    """One generation of Conway's Game of Life (toroidal, optimized)."""
    new = [[False] * cols for _ in range(rows)]
    for r in range(rows):
        rm = (r - 1) % rows
        rp = (r + 1) % rows
        row_m, row_0, row_p = grid[rm], grid[r], grid[rp]
        for c in range(cols):
            cm = (c - 1) % cols
            cp = (c + 1) % cols
            n = row_m[cm] + row_m[c] + row_m[cp] + row_0[cm] + row_0[cp] + row_p[cm] + row_p[c] + row_p[cp]
            if n == 3 or (n == 2 and row_0[c]):
                new[r][c] = True
    return new


def life_render(grid, rows, cols, char_w, char_h):
    """Render grid as list of [(char, density), ...] per row. Density 0-8 = alive dots per braille cell."""
    lines = []
    for cy in range(char_h):
        row = []
        for cx in range(char_w):
            code = 0x2800
            alive = 0
            for dy in range(4):
                for dx in range(2):
                    gr, gc = cy * 4 + dy, cx * 2 + dx
                    if gr < rows and gc < cols and grid[gr][gc]:
                        alive += 1
                        if dx == 0:
                            code |= 1 << [0, 1, 2, 6][dy]
                        else:
                            code |= 1 << [3, 4, 5, 7][dy]
            row.append((chr(code), alive))
        lines.append(row)
    return lines


def _progress_bar(done, in_progress, total, width=5):
    """Build a compact progress bar: █ for done, ▓ for in_progress, ░ for remaining."""
    if total <= 0:
        return "░" * width
    filled = int(done / total * width)
    active = int(in_progress / total * width)
    # Ensure at least 1 char for in_progress if any exist
    if in_progress > 0 and active == 0 and filled < width:
        active = 1
    remaining = width - filled - active
    return "█" * filled + "▓" * active + "░" * max(0, remaining)


def member_status(activity_buckets, session):
    """Return (icon, color) based on member activity."""
    recent = activity_buckets[-5:] if activity_buckets else []
    has_recent_tools = any(b > 0 for b in recent)
    waiting = bool(session.get("lastWaitUserAt"))
    if has_recent_tools:
        return ("◉", GREEN)
    elif waiting:
        return ("○", DIM)
    else:
        return ("◎", YELLOW)


# ── BOX DRAWING ──────────────────────────────────────────────

def draw_box(stdscr, y, x, h, w, title="", title_attr=0, border_attr=0):
    if h < 2 or w < 2:
        return
    ba = border_attr or DIM
    ta = title_attr or CYAN
    top = SYMBOLS["tl"] + SYMBOLS["h"] * (w - 2) + SYMBOLS["tr"]
    if title:
        label = f" {title} "
        if len(label) + 2 < w:
            top = top[:2] + label + top[2 + len(label):]
    safe_add(stdscr, y, x, top, x + w, ba)
    if title:
        safe_add(stdscr, y, x + 2, f" {title} ", x + w, ta)
    for row in range(y + 1, y + h - 1):
        safe_add(stdscr, row, x, SYMBOLS["v"], x + w, ba)
        safe_add(stdscr, row, x + w - 1, SYMBOLS["v"], x + w, ba)
    bot = SYMBOLS["bl"] + SYMBOLS["h"] * (w - 2) + SYMBOLS["br"]
    safe_add(stdscr, y + h - 1, x, bot, x + w, ba)


# ── MAIN DRAW + LOOP ────────────────────────────────────────

def refresh_data(cache: dict, stats_range_idx: int = 2) -> dict:
    """Refresh cached dashboard data from DB + filesystem."""
    data = query_db(DB_PATH, stats_range_idx)
    active_all = data["active_sessions"]
    active_sids_all = {s["session_id"] for s in active_all}
    team_data = query_teams(DB_PATH, active_sids_all)
    cache.update({
        "data": data,
        "active_all": active_all,
        "r_agents": data["running_agents"],
        "c_agents": data["completed_agents"],
        "recent": data["recent_prompts"],
        "tool_events": data["tool_events"],
        "session_tools": data["session_tools"],
        "activity": data["activity"],
        "team_data": team_data,
        "session_lookup": {s["session_id"]: s for s in active_all},
    })
    return cache


def _detail_content_height(sel_agent, pw, cache):
    """Estimate how many content rows DETAIL needs (excluding box borders)."""
    if not sel_agent:
        return 3
    if sel_agent.get("is_session"):
        rows = 2  # header + divider
        prompt = (sel_agent.get("prompt", "") or "").replace("\n", " ").strip()
        if prompt:
            rows += 1  # prompt line
        sid = sel_agent.get("session_id", "")
        n_tools = len(cache.get("session_tools", {}).get(sid, []))
        if n_tools:
            rows += 1 + n_tools  # blank + tool lines
        return rows
    if sel_agent.get("is_teammate"):
        tasks = sel_agent.get("_tasks", [])
        return 2 + (1 if not tasks else 2 + len(tasks))  # header + divider + progress + blank + tasks
    # Agent transcript — cap preview at 8
    return 2 + 8


def _draw_detail(stdscr, pr, col, max_row, max_col, sel_agent, cache, scroll=0):
    """Render DETAIL content into a region defined by (pr, col) to (max_row, max_col)."""
    pw = max_col - col  # available width
    base_pr = pr  # top of drawable area

    def P(r, c, text, attr=0):
        sr = r - scroll  # screen row after scroll
        if base_pr <= sr < max_row:
            safe_add(stdscr, sr, c, text, max_col, attr)

    # Adjust max_row for virtual space (allow pr to go beyond visible area)
    max_row_virtual = max_row + scroll

    if sel_agent and sel_agent.get("is_session"):
        # Rich session detail
        sid = sel_agent["session_id"]
        dur = fmt_dur(sel_agent.get("started_at", ""))
        sid_short = sid[:7]
        cwd = sel_agent.get("cwd", "")
        prompt_text = sel_agent.get("prompt", "")
        tag = dir_tag(cwd)
        header = f"{sid_short} \u00b7 {tag} session \u00b7 {dur}" if tag else f"{sid_short} \u00b7 session \u00b7 {dur}"
        P(pr, col, header[:pw], GREEN | curses.A_BOLD)
        pr += 1
        P(pr, col, SYMBOLS["h"] * pw, DIM)
        pr += 1

        # Prompt
        if prompt_text and pr < max_row_virtual:
            display_prompt = prompt_text.replace("\n", " ").strip()
            if display_prompt.startswith("<"):
                display_prompt = "(system prompt)"
            P(pr, col, display_prompt[:pw], WHITE)
            pr += 1

        # Tool event timeline
        session_tools = cache.get("session_tools", {}).get(sid, [])
        if session_tools and pr < max_row_virtual:
            pr += 1
            for ev in session_tools:
                if pr >= max_row_virtual:
                    break
                ts = fmt_time(ev.get("created_at"))
                name = ev["tool_name"]
                label = ev["tool_label"]
                tool_str = f"{name}\u2192{label}" if label and label != name else name
                P(pr, col, ts, DIM)
                P(pr, col + 9, tool_str[:pw - 10], YELLOW)
                pr += 1

    elif sel_agent and sel_agent.get("is_teammate"):
        # Task list for selected team member
        team_name = sel_agent.get("team_name", "")
        teammate_name = sel_agent.get("teammate_name", "")
        dur = fmt_dur(sel_agent.get("started_at", ""))
        sid_short = sel_agent["agent_id"][:7]
        header = f"{sid_short} \u00b7 {team_name}/{teammate_name} \u00b7 {dur}"
        P(pr, col, header[:pw], CYAN | curses.A_BOLD)
        pr += 1
        P(pr, col, SYMBOLS["h"] * pw, DIM)
        pr += 1
        tasks_list = sel_agent.get("_tasks", [])
        sorted_tasks = sorted(
            tasks_list,
            key=lambda t: {"in_progress": 0, "pending": 1, "completed": 2}.get(t.get("status", ""), 1),
        )
        if not sorted_tasks:
            P(pr, col, "(no tasks)", DIM)
        else:
            t_done = sum(1 for t in sorted_tasks if t.get("status") == "completed")
            t_active = sum(1 for t in sorted_tasks if t.get("status") == "in_progress")
            t_blocked = sum(1 for t in sorted_tasks if t.get("status") == "pending" and t.get("blockedBy"))
            t_total = len(sorted_tasks)
            pbar = _progress_bar(t_done, t_active, t_total, 10)
            pct = int(t_done / t_total * 100) if t_total else 0
            parts = [f"{t_done} done"]
            if t_active:
                parts.append(f"{t_active} active")
            if t_blocked:
                parts.append(f"{t_blocked} blocked")
            t_pending_unblocked = t_total - t_done - t_active - t_blocked
            if t_pending_unblocked > 0:
                parts.append(f"{t_pending_unblocked} pending")
            P(pr, col, f"{pbar} {pct}%  {' \u00b7 '.join(parts)}", CYAN)
            pr += 1
            pr += 1  # blank line

            for t in sorted_tasks:
                if pr >= max_row_virtual:
                    break
                status = t.get("status", "")
                blocked = bool(t.get("blockedBy")) and status == "pending"
                if status == "completed":
                    icon = "\u2713"
                elif status == "in_progress":
                    icon = "\u25cf"
                elif blocked:
                    icon = "\u2298"
                else:
                    icon = "\u25cb"
                owner = t.get("owner", "")
                owner_tag = f"  [@{owner}]" if owner else ""
                subject = short_prompt(t.get("subject", "?"), pw - 6 - len(owner_tag))
                if status == "completed":
                    attr = DIM
                elif status == "in_progress":
                    attr = YELLOW
                elif blocked:
                    attr = RED
                else:
                    attr = WHITE
                P(pr, col, f"{icon}  {subject}{owner_tag}", attr)
                pr += 1

    elif sel_agent:
        # Live preview of selected subagent
        dur = fmt_dur(sel_agent["started_at"])
        atype = sel_agent.get("agent_type") or "agent"
        aid = sel_agent["agent_id"][:7]
        tag = dir_tag(sel_agent.get("cwd", ""))
        header = f"{aid} \u00b7 {tag} {atype} \u00b7 {dur}" if tag else f"{aid} \u00b7 {atype} \u00b7 {dur}"
        P(pr, col, header[:pw], MAGENTA | curses.A_BOLD)
        pr += 1
        P(pr, col, SYMBOLS["h"] * pw, DIM)
        pr += 1
        for line in read_preview_lines(sel_agent, max_row_virtual - pr):
            if pr >= max_row_virtual:
                break
            P(pr, col, line[:pw], WHITE)
            pr += 1

    else:
        # Nothing selected — show keybinding hints
        P(pr, col, "j/k  select", DIM)
        pr += 1
        P(pr, col, "esc  deselect", DIM)
        pr += 1
        P(pr, col, "ret  open in iTerm2", DIM)


def draw(stdscr, frame: int, state: dict, cache: dict):
    stdscr.erase()
    h, w = stdscr.getmaxyx()
    if h < 5 or w < 30:
        safe_add(stdscr, 0, 0, "terminal too small", w, 0)
        stdscr.refresh()
        return

    spins = "\u280b\u2819\u2839\u2838\u283c\u2834\u2826\u2827\u2807\u280f"
    sc = spins[frame % len(spins)]
    pulse = ("○", "◎", "●", "◎")[frame % 4]

    active_all = cache["active_all"]
    r_agents = cache["r_agents"]
    c_agents = cache["c_agents"]
    recent = cache["recent"]
    tool_events = cache["tool_events"]
    activity = cache["activity"]
    team_data = cache["team_data"]
    session_lookup = cache["session_lookup"]

    team_session_ids = team_data["team_session_ids"]
    teams = team_data["teams"]

    # Solo sessions: exclude team members (shown in TEAMS section instead)
    active = [s for s in active_all if s["session_id"] not in team_session_ids]

    # Build agents_by_session, track orphans
    active_sids = {s["session_id"] for s in active}
    agents_by_session: dict[str, list[dict]] = {}
    orphan_agents: list[dict] = []
    for a in r_agents:
        if a["session_id"] in active_sids:
            agents_by_session.setdefault(a["session_id"], []).append(a)
        else:
            orphan_agents.append(a)

    # Layout
    split = w >= 100
    lw = (w * 3) // 5 if split else w
    rw = w - lw if split else 0
    rx = lw  # right panel x position

    top_agents = cache["data"].get("top_agents", [])
    top_tools = cache["data"].get("top_tools", [])

    # Helpers: clip to panel widths (preserve box borders)
    def L(r, c, text, attr=0):
        safe_add(stdscr, r, c, text, lw - 1, attr)

    def R(r, c, text, attr=0):
        safe_add(stdscr, r, c, text, rx + rw - 1, attr)

    # Reset visible items for keyboard nav
    visible_items: list[dict] = []

    n_team_members = sum(len(t["members"]) for t in teams)
    total_live = len(active) + len(r_agents) + n_team_members

    # -- Title bar (row 0-1, full width) --
    row = 0
    now = datetime.now(timezone.utc).strftime("%H:%M:%S")
    if total_live > 0:
        title = f" {sc} CLAUDE AGENTS"
        counts = []
        if teams:
            tm_count = n_team_members
            counts.append(f"{len(teams)} team{'s' if len(teams) != 1 else ''} \u00b7 {tm_count} active")
        if active:
            counts.append(f"{len(active)} session{'s' if len(active) != 1 else ''}")
        if r_agents:
            counts.append(f"{len(r_agents)} agent{'s' if len(r_agents) != 1 else ''}")
        count_str = f"  {' \u00b7 '.join(counts)}"
        title_attr = YELLOW
    else:
        title = "   CLAUDE AGENTS"
        count_str = "  idle"
        title_attr = GREEN

    safe_add(stdscr, row, 0, title, w, title_attr)
    safe_add(stdscr, row, len(title), count_str, w, DIM)
    safe_add(stdscr, row, w - len(now) - 1, now, w, DIM)
    row += 1
    safe_add(stdscr, row, 0, SYMBOLS["h"] * w, w, DIM)
    row += 1
    content_top = row

    # -- Compute panel heights --
    # Teams panel
    n_team_subheaders = len(teams) if len(teams) > 1 else 0
    n_active_task_rows = 0
    for team in teams:
        for m in team["members"]:
            if any(t.get("owner") == m.get("teammate_name") and t.get("status") == "in_progress"
                   for t in team["tasks"]):
                n_active_task_rows += 1
    teams_h = (2 + n_team_members + n_active_task_rows + n_team_subheaders) if teams else 0

    # Sessions panel: each session gets 1 row + 1 inline tool row if it has recent tools
    n_sess_rows = 0
    for s in active:
        n_sess_rows += 1
        if s["session_id"] in tool_events:
            n_sess_rows += 1  # inline tool line
    n_sess_rows += len(orphan_agents)
    sess_h = (2 + n_sess_rows) if (active or orphan_agents) else 0

    # History + Stats share remaining left-panel space
    max_hist = 8
    remaining = max(6, h - content_top - teams_h - sess_h - 1)
    hist_h = min(2 + max_hist, remaining // 2 + remaining % 2)
    stats_lh = remaining - hist_h  # left-side stats height

    # If nothing active, show a small sessions box with idle message
    if not teams and not active and not r_agents:
        sess_h = 3
        remaining = max(6, h - content_top - sess_h - 1)
        hist_h = min(2 + max_hist, remaining // 2 + remaining % 2)
        stats_lh = remaining - hist_h

    # -- TEAMS panel --
    cr = content_top
    if teams:
        # Build title
        if len(teams) == 1:
            t0 = teams[0]
            tl = t0["tasks"]
            tdone = sum(1 for x in tl if x.get("status") == "completed")
            trinp = sum(1 for x in tl if x.get("status") == "in_progress")
            ttotal = len(tl)
            if ttotal > 0:
                bar = _progress_bar(tdone, trinp, ttotal, 5)
                tcounts = f"  {bar} {tdone}/{ttotal}"
            else:
                tcounts = ""
            box_title = f"TEAMS  {t0['name']}{tcounts}"
        else:
            box_title = f"TEAMS  {len(teams)} teams \u00b7 {n_team_members} active"

        draw_box(stdscr, cr, 0, teams_h, lw, title=box_title)
        tr = cr + 1  # first content row inside box

        for team in teams:
            if tr >= cr + teams_h - 1:
                break
            if len(teams) > 1:
                # Sub-header per team
                tl = team["tasks"]
                tdone = sum(1 for x in tl if x.get("status") == "completed")
                trinp = sum(1 for x in tl if x.get("status") == "in_progress")
                ttotal = len(tl)
                if ttotal > 0:
                    bar = _progress_bar(tdone, trinp, ttotal, 5)
                    tcounts = f"  {bar} {tdone}/{ttotal}"
                else:
                    tcounts = ""
                L(tr, 2, f"\u25c8 {team['name']}{tcounts}", CYAN)
                tr += 1
                base = 4
            else:
                base = 2

            members = team["members"]
            for i, m in enumerate(members):
                if tr >= cr + teams_h - 1:
                    break
                is_last = (i == len(members) - 1)
                connector = "\u2514\u2500" if is_last else "\u251c\u2500"
                sess = session_lookup.get(m["session_id"], {})
                started_at = sess.get("created_at", "")
                dur = fmt_dur(started_at) if started_at else "?"
                teammate_name = m.get("teammate_name") or "teammate"
                sid_short = short_session(m["session_id"])
                item = {
                    "agent_id": m["session_id"],
                    "agent_type": teammate_name,
                    "session_id": m["session_id"],
                    "started_at": started_at,
                    "cwd": sess.get("cwd", ""),
                    "team_name": team["name"],
                    "teammate_name": teammate_name,
                    "is_teammate": True,
                    "_tasks": team["tasks"],
                }
                vidx = len(visible_items)
                visible_items.append(item)
                is_sel = (vidx == state.get("selected", -1))

                # Sparkline + status for this teammate
                spark = sparkline(activity.get(m["session_id"], []))
                s_icon, s_color = member_status(activity.get(m["session_id"], []), sess)

                if is_sel:
                    try:
                        stdscr.addnstr(tr, 1, " " * (lw - 2), lw - 2, SEL_DIM)
                    except curses.error:
                        pass
                    L(tr, base, connector, SEL_DIM)
                    L(tr, base + 3, "\u25b6", SEL_YELLOW)
                    L(tr, base + 5, f"{dur:>5}", SEL_YELLOW)
                    L(tr, base + 11, sid_short, SEL_DIM)
                    L(tr, base + 18, teammate_name, SEL)
                    L(tr, lw - 12, spark, SEL_DIM)
                else:
                    L(tr, base, connector, DIM)
                    L(tr, base + 3, s_icon, s_color)
                    L(tr, base + 5, f"{dur:>5}", YELLOW)
                    L(tr, base + 11, sid_short, DIM)
                    L(tr, base + 18, teammate_name, WHITE)
                    L(tr, lw - 12, spark, CYAN)
                tr += 1

                # Active task row under this member
                active_task = None
                for t in team["tasks"]:
                    if t.get("owner") == teammate_name and t.get("status") == "in_progress":
                        active_task = t
                        break
                if active_task and tr < cr + teams_h - 1:
                    continuation = "\u2502" if not is_last else " "
                    task_text = active_task.get("activeForm") or active_task.get("subject", "")
                    task_text = task_text[:lw - base - 10]
                    if is_sel:
                        try:
                            stdscr.addnstr(tr, 1, " " * (lw - 2), lw - 2, SEL_DIM)
                        except curses.error:
                            pass
                        L(tr, base, continuation, SEL_DIM)
                        L(tr, base + 5, "\u25cf", SEL_YELLOW)
                        L(tr, base + 7, task_text, SEL_YELLOW)
                    else:
                        L(tr, base, continuation, DIM)
                        L(tr, base + 5, "\u25cf", YELLOW)
                        L(tr, base + 7, task_text, YELLOW)
                    tr += 1

        cr += teams_h

    # -- SESSIONS panel --
    if active or orphan_agents:
        n_running = sum(
            1 for s in active
            if not s.get("lastWaitUserAt") or s["session_id"] in agents_by_session
        )
        n_waiting = len(active) - n_running
        sess_counts = []
        if n_running:
            sess_counts.append(f"{n_running} running")
        if n_waiting:
            sess_counts.append(f"{n_waiting} waiting")
        if r_agents:
            sess_counts.append(f"{len(r_agents)} agent{'s' if len(r_agents) != 1 else ''}")
        sess_title = f"SESSIONS  {' \u00b7 '.join(sess_counts)}" if sess_counts else "SESSIONS"

        draw_box(stdscr, cr, 0, sess_h, lw, title=sess_title)
        sr = cr + 1

        for s in active:
            if sr >= cr + sess_h - 1:
                break
            sid = s["session_id"]
            has_agents = sid in agents_by_session
            waiting = bool(s.get("lastWaitUserAt")) and not has_agents
            sid_short = short_session(sid)
            prompt = short_prompt(s.get("prompt"), max(10, lw - 32))
            spark = sparkline(activity.get(sid, []))

            # Make session selectable
            sess_item = {
                "agent_id": sid,
                "agent_type": "session",
                "session_id": sid,
                "started_at": s["created_at"],
                "cwd": s.get("cwd", ""),
                "is_session": True,
                "prompt": s.get("prompt", ""),
            }
            vidx = len(visible_items)
            visible_items.append(sess_item)
            is_sel = (vidx == state.get("selected", -1))

            if is_sel:
                try:
                    stdscr.addnstr(sr, 1, " " * (lw - 2), lw - 2, SEL_DIM)
                except curses.error:
                    pass
                L(sr, 2, "\u25b6", SEL_YELLOW)
                run_dur = fmt_dur(s["created_at"])
                L(sr, 4, f"{run_dur:>6}", SEL_YELLOW)
                L(sr, 11, sid_short, SEL_DIM)
                L(sr, 18, prompt, SEL)
                L(sr, lw - 12, spark, SEL_DIM)
            elif waiting:
                wait_dur = fmt_dur(s["lastWaitUserAt"])
                L(sr, 2, "\u25cb", YELLOW)
                L(sr, 4, f"~{wait_dur:>5}", DIM)
                L(sr, 11, sid_short, DIM)
                L(sr, 18, prompt, DIM)
            else:
                run_dur = fmt_dur(s["created_at"])
                L(sr, 2, pulse, GREEN)
                L(sr, 4, f"{run_dur:>6}", YELLOW)
                L(sr, 11, sid_short, DIM)
                L(sr, 18, prompt, WHITE)
                L(sr, lw - 12, spark, CYAN)
            sr += 1

            # Inline tool line (most recent tool call for this session)
            if sid in tool_events and sr < cr + sess_h - 1:
                tools = tool_events[sid]
                parts = []
                for t in tools:
                    name = t["tool_name"]
                    label = t["tool_label"]
                    parts.append(f"{name}\u2192{label}" if label and label != name else name)
                tool_line = "  ".join(parts)[:lw - 8]
                if is_sel:
                    try:
                        stdscr.addnstr(sr, 1, " " * (lw - 2), lw - 2, SEL_DIM)
                    except curses.error:
                        pass
                    L(sr, 4, "\u23bf", SEL_DIM)
                    L(sr, 6, tool_line, SEL_DIM)
                else:
                    L(sr, 4, "\u23bf", DIM)
                    L(sr, 6, tool_line, DIM)
                sr += 1

        # Orphan agents
        for a in orphan_agents:
            if sr >= cr + sess_h - 1:
                break
            dur = fmt_dur(a["started_at"])
            atype = a["agent_type"] or "agent"
            tag = dir_tag(a.get("cwd", ""))
            vidx = len(visible_items)
            visible_items.append(a)
            is_sel = (vidx == state.get("selected", -1))
            a_spark = sparkline(activity.get(a.get("session_id", ""), []))

            if is_sel:
                try:
                    stdscr.addnstr(sr, 1, " " * (lw - 2), lw - 2, SEL_DIM)
                except curses.error:
                    pass
                L(sr, 2, "\u25b6", SEL_YELLOW)
                L(sr, 4, f"{dur:>6}", SEL_YELLOW)
                col = 11
                if tag:
                    L(sr, col, tag, SEL_CYAN)
                    col += len(tag) + 1
                L(sr, col, atype, SEL)
                L(sr, col + len(atype) + 1, short_id(a["agent_id"]), SEL_DIM)
                L(sr, lw - 12, a_spark, SEL_DIM)
            else:
                L(sr, 2, sc, MAGENTA)
                L(sr, 4, f"{dur:>6}", YELLOW)
                col = 11
                if tag:
                    L(sr, col, tag, CYAN)
                    col += len(tag) + 1
                L(sr, col, atype, MAGENTA)
                L(sr, col + len(atype) + 1, short_id(a["agent_id"]), DIM)
                L(sr, lw - 12, a_spark, CYAN)
            sr += 1

        cr += sess_h

    elif not teams:
        # No active sessions or agents — show idle box
        draw_box(stdscr, cr, 0, sess_h, lw, title="SESSIONS")
        L(cr + 1, 2, "no active sessions or agents", DIM)
        cr += sess_h

    # -- HISTORY or DETAIL-inline panel --
    # When something is selected and terminal is too narrow for side-by-side,
    # show DETAIL in the HISTORY panel's space instead.
    sel_idx = state.get("selected", -1)
    sel_agent = visible_items[sel_idx] if 0 <= sel_idx < len(visible_items) else None
    show_inline_detail = sel_agent is not None and not split

    if show_inline_detail:
        draw_box(stdscr, cr, 0, hist_h, lw, title="DETAIL")
        _draw_detail(stdscr, cr + 1, 2, cr + hist_h - 1, lw - 1,
                     sel_agent, cache)
    else:
        draw_box(stdscr, cr, 0, hist_h, lw, title="HISTORY")
        hr = cr + 1

        history = []
        for a in c_agents:
            history.append(("agent", a["stopped_at"], a))
        for s in recent:
            history.append(("prompt", s["stoped_at"], s))
        history.sort(key=lambda x: x[1] or "", reverse=True)

        if not history:
            L(hr, 2, "(empty)", DIM)
        else:
            shown = 0
            for kind, ts, item in history:
                if hr >= cr + hist_h - 1 or shown >= max_hist:
                    break
                t = fmt_time(ts)
                if kind == "agent":
                    dur = fmt_dur(item["started_at"], item["stopped_at"])
                    atype = item.get("agent_type") or "agent"
                    hist_item = {
                        "agent_id": item.get("agent_id", ""),
                        "agent_type": atype,
                        "session_id": item.get("session_id", ""),
                        "started_at": item.get("started_at", ""),
                        "cwd": item.get("cwd", ""),
                        "is_history": True,
                        "kind": "agent",
                        "stopped_at": item.get("stopped_at", ""),
                        "transcript_path": item.get("transcript_path", ""),
                    }
                elif kind == "prompt":
                    dur = fmt_dur(item["created_at"], item["stoped_at"])
                    prompt = short_prompt(item.get("prompt"), max(10, lw - 21))
                    if not prompt:
                        continue
                    hist_item = {
                        "agent_id": item.get("session_id", ""),
                        "agent_type": "session",
                        "session_id": item.get("session_id", ""),
                        "started_at": item.get("created_at", ""),
                        "cwd": item.get("cwd", ""),
                        "is_history": True,
                        "is_session": True,
                        "kind": "prompt",
                        "prompt": item.get("prompt", ""),
                    }
                else:
                    continue

                vidx = len(visible_items)
                visible_items.append(hist_item)
                is_sel = (vidx == state.get("selected", -1))

                if kind == "agent":
                    if is_sel:
                        try:
                            stdscr.addnstr(hr, 1, " " * (lw - 2), lw - 2, SEL_DIM)
                        except curses.error:
                            pass
                        L(hr, 2, t, SEL_DIM)
                        L(hr, 11, f"{dur:>6}", SEL_DIM)
                        L(hr, 18, f"\u25b8 {atype}", SEL_MAGENTA)
                    else:
                        L(hr, 2, t, DIM)
                        L(hr, 11, f"{dur:>6}", DIM)
                        L(hr, 18, f"\u25b8 {atype}", curses.color_pair(6))
                else:
                    if is_sel:
                        try:
                            stdscr.addnstr(hr, 1, " " * (lw - 2), lw - 2, SEL_DIM)
                        except curses.error:
                            pass
                        L(hr, 2, t, SEL_DIM)
                        L(hr, 11, f"{dur:>6}", SEL_DIM)
                        L(hr, 18, prompt, SEL)
                    else:
                        L(hr, 2, t, DIM)
                        L(hr, 11, f"{dur:>6}", DIM)
                        L(hr, 18, prompt, DIM)
                hr += 1
                shown += 1

    # -- STATS panel (bottom-left, below history) --
    cr_stats = cr + hist_h
    if stats_lh >= 4:
        range_label, _ = STATS_RANGES[state.get("stats_range", 2)]
        range_tabs = "  ".join(
            f"[{r[0]}]" if i == state.get("stats_range", 2) else r[0]
            for i, r in enumerate(STATS_RANGES)
        )
        draw_box(stdscr, cr_stats, 0, stats_lh, lw, title=f"STATS  {range_tabs}")
        sr = cr_stats + 1
        max_sr = cr_stats + stats_lh - 1

        def _bar(val: int, max_val: int, bw: int = 8) -> str:
            filled = int(val / max_val * bw) if max_val > 0 else 0
            return "\u2588" * filled + "\u2591" * (bw - filled)

        # Team metrics
        if teams and sr < max_sr - 2:
            for team in teams:
                if sr >= max_sr - 1:
                    break
                tl = team["tasks"]
                t_done = sum(1 for t in tl if t.get("status") == "completed")
                t_active = sum(1 for t in tl if t.get("status") == "in_progress")
                t_pending = sum(1 for t in tl if t.get("status") == "pending")
                t_total = len(tl)
                L(sr, 2, f"TEAMS  {team['name']}", CYAN)
                sr += 1
                if t_total > 0:
                    bar = _progress_bar(t_done, t_active, t_total, 10)
                    summary = f"{bar} {t_total} task{'s' if t_total != 1 else ''}  {t_done} done  {t_active} active  {t_pending} pending"
                    L(sr, 2, summary, DIM)
                    sr += 1
                sr += 1

        # Agent rankings (7d)
        if top_agents and sr < max_sr - 1:
            L(sr, 2, f"AGENTS  {range_label}", CYAN)
            sr += 1
            max_a = top_agents[0]["cnt"]
            tag_w = max((len(dir_tag(e.get("cwd", ""))) for e in top_agents), default=0)
            type_w = max((len(e["agent_type"] or "?") for e in top_agents), default=0)
            for entry in top_agents:
                if sr >= max_sr:
                    break
                tag = dir_tag(entry.get("cwd", ""))
                atype = entry["agent_type"] or "?"
                cnt = entry["cnt"]
                bar = _bar(cnt, max_a)
                col1 = tag.ljust(tag_w)
                col2 = atype.ljust(type_w)
                L(sr, 2, f"{col1}  {col2}  {bar} {cnt}", DIM)
                sr += 1
            sr += 1

        # Tool rankings (7d)
        if top_tools and sr < max_sr - 1:
            L(sr, 2, f"TOOLS   {range_label}", CYAN)
            sr += 1
            max_t = top_tools[0]["cnt"]
            ttag_w = max((len(dir_tag(e.get("cwd", ""))) for e in top_tools), default=0)
            tname_w = max((len(e["tool_name"] or "?") for e in top_tools), default=0)
            for entry in top_tools:
                if sr >= max_sr:
                    break
                tag = dir_tag(entry.get("cwd", ""))
                tname = entry["tool_name"] or "?"
                cnt = entry["cnt"]
                bar = _bar(cnt, max_t)
                col1 = tag.ljust(ttag_w)
                col2 = tname.ljust(tname_w)
                L(sr, 2, f"{col1}  {col2}  {bar} {cnt}", DIM)
                sr += 1

    # Clamp selection to visible items
    state["visible_items"] = visible_items
    if visible_items:
        state["selected"] = max(-1, min(state.get("selected", -1), len(visible_items) - 1))
    else:
        state["selected"] = -1

    # -- Right panel (DETAIL + LIFE) --
    if split and rw > 10:
        total_rh = h - content_top - 1
        if sel_agent:
            content_rows = _detail_content_height(sel_agent, rw - 4, cache)
            detail_h = min(content_rows + 2, total_rh - 4)  # +2 for box borders, leave room for Life
            focused = state.get("focus") == "right"
            title_str = "\u25b6 DETAIL" if focused else "DETAIL"
            draw_box(stdscr, content_top, rx, detail_h, rw, title=title_str,
                     border_attr=CYAN if focused else 0)
            scroll = state.get("detail_scroll", 0) if focused else 0
            _draw_detail(stdscr, content_top + 1, rx + 2, content_top + detail_h - 1, rx + rw - 1,
                         sel_agent, cache, scroll=scroll)
        else:
            detail_h = 0

        # -- LIFE panel (below detail, or full right panel) --
        life_y = content_top + detail_h
        life_rh = total_rh - detail_h
        if state.get("game_of_life") and life_rh >= 4:
            # Welcome screen for first 5 seconds
            life_started = state.setdefault("life_started", time.time())
            show_welcome = (time.time() - life_started) < 5.0

            life_sid = None
            if sel_agent and sel_agent.get("is_session"):
                life_sid = sel_agent["session_id"]
            if not life_sid and active_all:
                life_sid = active_all[0]["session_id"]
            if not life_sid:
                life_sid = "idle"
            if life_sid and show_welcome:
                wy = life_y + 1
                # Centered welcome block
                lines_w = [
                    ("GAME OF LIFE", CYAN | curses.A_BOLD),
                    ("", DIM),
                    ("Cells live, die, or spawn by neighbor count.", DIM),
                    (f"Seed: {life_sid[:7]}", YELLOW),
                ]
                cy = life_y + max(0, (life_rh - len(lines_w)) // 2)
                for text, attr in lines_w:
                    if cy >= life_y + life_rh:
                        break
                    cx = rx + max(2, (rw - len(text)) // 2)
                    safe_add(stdscr, cy, cx, text, rx + rw - 1, attr)
                    cy += 1
            elif life_sid:
                char_w = rw - 4
                char_h = life_rh - 1
                grid_rows = char_h * 4
                grid_cols = char_w * 2
                life_grids = state.setdefault("life_grids", {})
                if life_sid not in life_grids:
                    sess_info = session_lookup.get(life_sid, {})
                    seed_str = (sess_info.get("prompt", "") or "") + life_sid
                    random.seed(hash(seed_str))
                    life_grids[life_sid] = {
                        "grid": life_init(grid_rows, grid_cols, 0.25),
                        "size": (grid_rows, grid_cols),
                        "gen": 0,
                    }
                    random.seed()
                elif life_grids[life_sid]["size"] != (grid_rows, grid_cols):
                    # Resize: crop or extend existing grid (no re-seed)
                    old_grid = life_grids[life_sid]["grid"]
                    old_r, old_c = life_grids[life_sid]["size"]
                    new_grid = [[False] * grid_cols for _ in range(grid_rows)]
                    for r in range(min(old_r, grid_rows)):
                        for c in range(min(old_c, grid_cols)):
                            new_grid[r][c] = old_grid[r][c]
                    life_grids[life_sid]["grid"] = new_grid
                    life_grids[life_sid]["size"] = (grid_rows, grid_cols)
                lg = life_grids[life_sid]
                for _ in range(5):  # 5 steps per frame = ~50 gen/s
                    lg["grid"] = life_step(lg["grid"], grid_rows, grid_cols)
                    lg["gen"] += 1
                alive = sum(sum(row) for row in lg["grid"])
                if alive < 5:
                        sess_info = session_lookup.get(life_sid, {})
                        seed_str = (sess_info.get("prompt", "") or "") + life_sid + str(lg["gen"])
                        random.seed(hash(seed_str))
                        lg["grid"] = life_init(grid_rows, grid_cols, 0.25)
                        random.seed()
                # Seed label top-right
                seed_label = life_sid[:7]
                safe_add(stdscr, life_y, rx + rw - len(seed_label) - 2, seed_label, rx + rw - 1, DIM)
                # Density -> color: sparse=dim, medium=cyan, dense=green, packed=yellow
                _life_colors = [DIM, DIM, CYAN, CYAN, GREEN, GREEN, YELLOW, YELLOW, YELLOW]
                lines = life_render(lg["grid"], grid_rows, grid_cols, char_w, char_h)
                lr = life_y
                for row in lines:
                    if lr >= life_y + life_rh:
                        break
                    cx = rx + 2
                    for ch, density in row:
                        if cx >= rx + rw - 1:
                            break
                        color = _life_colors[min(density, 8)]
                        safe_add(stdscr, lr, cx, ch, rx + rw - 1, color)
                        cx += 1
                    lr += 1

    # -- Footer (full width) --
    status = state.get("status_msg", "")
    if status and time.time() < state.get("status_until", 0):
        safe_add(stdscr, h - 1, 0, f" {status}", w, YELLOW)
    elif visible_items:
        if state.get("focus") == "right":
            safe_add(stdscr, h - 1, 0, " j/k=scroll detail  h=back  esc=back  q=quit", w, DIM)
        else:
            safe_add(stdscr, h - 1, 0, " j/k=select  l=detail  h/l=stats range  esc=deselect  q=quit", w, DIM)
    else:
        safe_add(stdscr, h - 1, 0, " q=quit", w, DIM)
    stdscr.refresh()


RENDER_MS = 100     # redraw interval (smooth animations)
DATA_FRAMES = 20    # refresh DB every N frames (~2s at 100ms)


def main(stdscr, game_of_life=False):
    curses.curs_set(0)
    stdscr.nodelay(True)
    stdscr.timeout(RENDER_MS)
    stdscr.keypad(True)

    init_colors()

    state: dict = {"selected": -1, "visible_items": [], "status_msg": "", "status_until": 0.0,
                   "stats_range": 2, "game_of_life": game_of_life, "focus": "left", "detail_scroll": 0}
    cache: dict = {}
    refresh_data(cache, state["stats_range"])
    frame = 0
    while True:
        if frame % DATA_FRAMES == 0:
            refresh_data(cache, state["stats_range"])
        draw(stdscr, frame, state, cache)
        frame += 1
        ch = stdscr.getch()
        if ch in (ord("q"), ord("Q")):
            break
        elif ch == 27:  # Esc
            if state["focus"] == "right":
                state["focus"] = "left"
                state["detail_scroll"] = 0
            else:
                state["selected"] = -1
        elif state["focus"] == "right":
            # Right panel focused: j/k scrolls detail, h goes back
            if ch in (ord("j"), curses.KEY_DOWN):
                state["detail_scroll"] = state.get("detail_scroll", 0) + 1
            elif ch in (ord("k"), curses.KEY_UP):
                state["detail_scroll"] = max(0, state.get("detail_scroll", 0) - 1)
            elif ch in (ord("h"), curses.KEY_LEFT):
                state["focus"] = "left"
                state["detail_scroll"] = 0
        else:
            # Left panel focused
            if ch in (ord("j"), curses.KEY_DOWN):
                agents = state["visible_items"]
                if agents:
                    state["selected"] = min(state["selected"] + 1, len(agents) - 1) if state["selected"] >= 0 else 0
            elif ch in (ord("k"), curses.KEY_UP):
                if state["selected"] > 0:
                    state["selected"] -= 1
            elif ch in (ord("l"), curses.KEY_RIGHT):
                if state["selected"] >= 0:
                    # Enter detail panel
                    state["focus"] = "right"
                    state["detail_scroll"] = 0
                else:
                    # Cycle stats range
                    old = state["stats_range"]
                    state["stats_range"] = min(old + 1, len(STATS_RANGES) - 1)
                    if state["stats_range"] != old:
                        refresh_data(cache, state["stats_range"])
            elif ch in (ord("h"), curses.KEY_LEFT):
                old = state["stats_range"]
                state["stats_range"] = max(old - 1, 0)
                if state["stats_range"] != old:
                    refresh_data(cache, state["stats_range"])
            elif ch in (10, 13, curses.KEY_ENTER):
                idx = state["selected"]
                agents = state["visible_items"]
                if 0 <= idx < len(agents):
                    item = agents[idx]
                    is_agent = not item.get("is_session") and not item.get("is_teammate")
                    is_history_agent = item.get("is_history") and item.get("kind") == "agent"
                    if is_agent or is_history_agent:
                        short = item["agent_id"][:7]
                        try:
                            err = open_agent_in_iterm2(item)
                            atype = (item.get("agent_type") or "agent")[:12]
                            state["status_msg"] = err if err else f"opened tab: {atype}-{short}"
                        except Exception as e:
                            state["status_msg"] = str(e)[:40]
                        state["status_until"] = time.time() + 3


def self_update():
    """Pull latest from GitHub and replace the running script."""
    import urllib.request
    raw_url = "https://raw.githubusercontent.com/kingsotn-twelve/claude-agents/main/claude-agents"
    try:
        with urllib.request.urlopen(raw_url, timeout=10) as resp:
            new_src = resp.read().decode()
    except Exception as e:
        print(f"update failed: {e}")
        sys.exit(1)
    # Extract remote version
    remote_ver = None
    for line in new_src.splitlines()[:30]:
        if line.startswith("VERSION"):
            remote_ver = line.split('"')[1]
            break
    if remote_ver == VERSION:
        print(f"already up to date (v{VERSION})")
        return
    # Overwrite self
    me = os.path.realpath(sys.argv[0])
    try:
        with open(me, "w") as f:
            f.write(new_src)
        print(f"updated v{VERSION} → v{remote_ver}")
    except Exception as e:
        print(f"write failed: {e}")
        sys.exit(1)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog="claude-agents",
        description="Live terminal dashboard for Claude Code sessions & agents.\n"
                    "Tree view: agents nested under sessions, tool feed for agentless sessions.\n"
                    "Run in a separate pane alongside Claude Code.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "--version", action="version", version=f"claude-agents v{VERSION}"
    )
    parser.add_argument(
        "--update", action="store_true", help="self-update from GitHub"
    )
    parser.add_argument(
        "--game-of-life", action="store_true", help="show Conway's Game of Life"
    )
    args = parser.parse_args()

    if args.update:
        self_update()
        sys.exit(0)

    try:
        curses.wrapper(lambda stdscr: main(stdscr, game_of_life=args.game_of_life))
    except KeyboardInterrupt:
        pass
