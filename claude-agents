#!/usr/bin/env python3
"""
claude-agents — live terminal dashboard for Claude Code sessions & agents.
btop-style TUI with rounded box panels, braille sparklines, and tree views.
Run in a separate pane: claude-agents
"""

import argparse
import curses
import glob
import json
import os
import sqlite3
import subprocess
import sys
import time
from datetime import datetime, timezone

VERSION = "0.5.2"

PREVIEW_ROWS = 7  # lines reserved for inline preview (divider + header + content)

DB_PATH = os.environ.get("CLAUDE_AGENTS_DB") or os.path.expanduser("~/.claude/ccnotify/ccnotify.db")

MAX_COMPLETED_AGENTS = 10
MAX_HISTORY = 20
MAX_TOOL_EVENTS = 3  # tools shown per agentless session

# ── CONSTANTS & SYMBOLS ──────────────────────────────────────

SYMBOLS = {"tl": "╭", "tr": "╮", "bl": "╰", "br": "╯", "h": "─", "v": "│", "lt": "├", "rt": "┤"}
BRAILLE = "⠀⠂⠄⠆⠈⠐⠒⠔⠖⠘⠠⠢⠤⠦⠨⠰⠲⠴⠶⠸⡀⡂⡄⡆⡈"

GREEN = CYAN = YELLOW = DIM = MAGENTA = WHITE = RED = 0
# Selection highlight variants (white-on-dark-gray)
SEL = SEL_DIM = SEL_CYAN = SEL_YELLOW = SEL_GREEN = SEL_MAGENTA = 0
BG_SEL = 236  # dark gray background


def init_colors():
    global GREEN, CYAN, YELLOW, DIM, MAGENTA, WHITE, RED
    global SEL, SEL_DIM, SEL_CYAN, SEL_YELLOW, SEL_GREEN, SEL_MAGENTA, BG_SEL
    curses.start_color()
    curses.use_default_colors()
    # Normal colors (pair 1-7)
    for i, c in enumerate([curses.COLOR_GREEN, curses.COLOR_WHITE, curses.COLOR_CYAN,
                           curses.COLOR_YELLOW, 8, curses.COLOR_MAGENTA, curses.COLOR_RED], 1):
        curses.init_pair(i, c, -1)
    GREEN = curses.color_pair(1) | curses.A_BOLD
    WHITE = curses.color_pair(2)
    CYAN = curses.color_pair(3) | curses.A_BOLD
    YELLOW = curses.color_pair(4) | curses.A_BOLD
    DIM = curses.color_pair(5)
    MAGENTA = curses.color_pair(6) | curses.A_BOLD
    RED = curses.color_pair(7) | curses.A_BOLD
    # Selection highlight colors (pair 11-16: foreground on dark gray)
    try:
        curses.init_pair(11, curses.COLOR_WHITE, BG_SEL)
        curses.init_pair(12, 8, BG_SEL)  # dim on dark gray
        curses.init_pair(13, curses.COLOR_CYAN, BG_SEL)
        curses.init_pair(14, curses.COLOR_YELLOW, BG_SEL)
        curses.init_pair(15, curses.COLOR_GREEN, BG_SEL)
        curses.init_pair(16, curses.COLOR_MAGENTA, BG_SEL)
        SEL = curses.color_pair(11) | curses.A_BOLD
        SEL_DIM = curses.color_pair(12)
        SEL_CYAN = curses.color_pair(13) | curses.A_BOLD
        SEL_YELLOW = curses.color_pair(14) | curses.A_BOLD
        SEL_GREEN = curses.color_pair(15) | curses.A_BOLD
        SEL_MAGENTA = curses.color_pair(16) | curses.A_BOLD
    except curses.error:
        # Fallback if terminal doesn't support 256 colors
        SEL = curses.A_REVERSE | curses.A_BOLD
        SEL_DIM = curses.A_REVERSE
        SEL_CYAN = curses.A_REVERSE | curses.A_BOLD
        SEL_YELLOW = curses.A_REVERSE | curses.A_BOLD
        SEL_GREEN = curses.A_REVERSE | curses.A_BOLD
        SEL_MAGENTA = curses.A_REVERSE | curses.A_BOLD


# ── DATA QUERIES ─────────────────────────────────────────────

def query_db(db_path: str) -> dict:
    data = {
        "active_sessions": [],
        "running_agents": [],
        "completed_agents": [],
        "recent_prompts": [],
        "tool_events": {},  # session_id -> [{tool_name, tool_label}]
        "tool_feed": [],  # [{session_id, tool_name, tool_label, created_at}] — recent across all sessions
        "session_tools": {},  # session_id -> [{tool_name, tool_label, created_at}] — extended list for detail view
        "top_agents": [],
        "top_tools": [],
        "activity": {},
    }
    if not os.path.exists(db_path):
        return data

    try:
        conn = sqlite3.connect(db_path)
        conn.row_factory = sqlite3.Row

        # Active sessions: latest prompt per session.
        # A session is "active" if un-stopped AND one of:
        #   - created within the last 5 min (grace period before first tool call)
        #   - waiting for user input within the last 30 min (time-bounded to avoid forever-stuck sessions)
        #   - had tool activity in the last 10 min (actively running)
        # This correctly hides sessions killed without Stop firing.
        for row in conn.execute(
            """SELECT p.session_id, p.prompt, p.cwd, p.created_at, p.seq, p.lastWaitUserAt
               FROM prompt p
               INNER JOIN (
                   SELECT session_id, MAX(id) as max_id
                   FROM prompt
                   WHERE stoped_at IS NULL
                     AND (
                       created_at > datetime('now', '-5 minutes')
                       OR (lastWaitUserAt IS NOT NULL AND lastWaitUserAt > datetime('now', '-30 minutes'))
                       OR session_id IN (
                         SELECT DISTINCT session_id FROM tool_event
                         WHERE created_at > datetime('now', '-10 minutes')
                       )
                     )
                   GROUP BY session_id
               ) latest ON p.id = latest.max_id
               ORDER BY p.created_at DESC
               LIMIT 10"""
        ):
            data["active_sessions"].append(dict(row))

        # Running agents (skip ghosts with empty type)
        for row in conn.execute(
            """SELECT agent_id, agent_type, session_id, cwd, started_at, transcript_path
               FROM agent
               WHERE stopped_at IS NULL
               ORDER BY started_at ASC"""
        ):
            data["running_agents"].append(dict(row))

        # Completed agents (skip ghosts)
        for row in conn.execute(
            f"""SELECT agent_id, agent_type, session_id, cwd, started_at, stopped_at
                FROM agent
                WHERE stopped_at IS NOT NULL
                ORDER BY stopped_at DESC
                LIMIT {MAX_COMPLETED_AGENTS}"""
        ):
            data["completed_agents"].append(dict(row))

        # Recent completed prompts (skip system/task-notification noise)
        for row in conn.execute(
            f"""SELECT session_id, prompt, cwd, created_at, stoped_at, seq
                FROM prompt
                WHERE stoped_at IS NOT NULL
                  AND prompt NOT LIKE '<%'
                ORDER BY stoped_at DESC
                LIMIT {MAX_HISTORY}"""
        ):
            data["recent_prompts"].append(dict(row))

        # Tool events: last N per active session, within last 10 min
        active_sids = [s["session_id"] for s in data["active_sessions"]]
        for sid in active_sids:
            tools = []
            for row in conn.execute(
                """SELECT tool_name, tool_label FROM tool_event
                   WHERE session_id = ?
                     AND created_at > datetime('now', '-10 minutes')
                   ORDER BY created_at DESC
                   LIMIT ?""",
                (sid, MAX_TOOL_EVENTS),
            ):
                tools.append(dict(row))
            if tools:
                # Reverse so oldest is first (left-to-right reading)
                data["tool_events"][sid] = list(reversed(tools))

        # Tool feed: recent tool events across all active sessions (for LIVE panel)
        try:
            for row in conn.execute(
                """SELECT session_id, tool_name, tool_label, created_at FROM tool_event
                   WHERE created_at > datetime('now', '-5 minutes')
                   ORDER BY created_at DESC
                   LIMIT 8"""
            ):
                data["tool_feed"].append(dict(row))
        except sqlite3.OperationalError:
            pass

        # Session tools: extended tool list per active session (for DETAIL view)
        for sid in active_sids:
            try:
                rows = []
                for row in conn.execute(
                    """SELECT tool_name, tool_label, created_at FROM tool_event
                       WHERE session_id = ?
                         AND created_at > datetime('now', '-30 minutes')
                       ORDER BY created_at DESC
                       LIMIT 20""",
                    (sid,),
                ):
                    rows.append(dict(row))
                if rows:
                    data["session_tools"][sid] = list(reversed(rows))
            except sqlite3.OperationalError:
                pass

        # Activity buckets for sparklines (last 60s, 20 buckets of 3s each)
        for sid in active_sids:
            try:
                rows = conn.execute(
                    "SELECT created_at FROM tool_event WHERE session_id = ? AND created_at > datetime('now', '-60 seconds')",
                    (sid,)).fetchall()
                buckets = [0] * 20
                now_utc = datetime.now(timezone.utc)
                for (ts_str,) in rows:
                    try:
                        ts = datetime.fromisoformat(ts_str).replace(tzinfo=timezone.utc)
                        age = (now_utc - ts).total_seconds()
                        slot = int(age / 3)
                        if 0 <= slot < 20:
                            buckets[19 - slot] += 1
                    except Exception:
                        pass
                data["activity"][sid] = buckets
            except Exception:
                pass

        # Usage stats: top agent types + top tools (last 7 days)
        try:
            data["top_agents"] = [
                dict(r) for r in conn.execute(
                    """SELECT agent_type, cwd, COUNT(*) as cnt FROM agent
                       WHERE started_at > datetime('now', '-7 days') AND agent_type != ''
                       GROUP BY agent_type, cwd ORDER BY cnt DESC LIMIT 12"""
                )
            ]
        except sqlite3.OperationalError:
            data["top_agents"] = []
        try:
            data["top_tools"] = [
                dict(r) for r in conn.execute(
                    """SELECT te.tool_name, p.cwd, COUNT(*) as cnt
                       FROM tool_event te
                       LEFT JOIN prompt p ON te.session_id = p.session_id
                       WHERE te.created_at > datetime('now', '-7 days')
                       GROUP BY te.tool_name, p.cwd ORDER BY cnt DESC LIMIT 12"""
                )
            ]
        except sqlite3.OperationalError:
            data["top_tools"] = []

        conn.close()
    except sqlite3.OperationalError:
        pass

    return data


def read_team_tasks(team_name: str) -> list[dict]:
    """Read task JSON files from ~/.claude/tasks/{team_name}/."""
    tasks_dir = os.path.expanduser(f"~/.claude/tasks/{team_name}")
    if not os.path.isdir(tasks_dir):
        return []
    tasks = []
    try:
        for path in glob.glob(os.path.join(tasks_dir, "*.json")):
            try:
                with open(path, "r", errors="replace") as f:
                    obj = json.load(f)
                if isinstance(obj, dict) and "status" in obj and "subject" in obj:
                    tasks.append(obj)
                elif isinstance(obj, list):
                    # Some implementations store all tasks in one file
                    for item in obj:
                        if isinstance(item, dict) and "status" in item and "subject" in item:
                            tasks.append(item)
            except Exception:
                pass
    except Exception:
        pass
    return tasks


def query_teams(db_path: str, active_session_ids: set[str]) -> dict:
    """Read team config files + task files; supplement with team_session DB table."""
    result: dict = {"teams": [], "team_session_ids": set()}
    teams_root = os.path.expanduser("~/.claude/teams")
    team_map: dict[str, dict] = {}  # team_name -> {name, members, tasks}

    # 1. Read file-system team configs
    if os.path.isdir(teams_root):
        for config_path in glob.glob(os.path.join(teams_root, "*/config.json")):
            try:
                with open(config_path, "r", errors="replace") as f:
                    cfg = json.load(f)
                team_name = cfg.get("name") or os.path.basename(os.path.dirname(config_path))
                members = []
                for m in cfg.get("members", []):
                    agent_id = m.get("agentId", "")
                    if agent_id:
                        members.append({
                            "session_id": agent_id,
                            "teammate_name": m.get("name", ""),
                            "agent_type": m.get("agentType", ""),
                        })
                        result["team_session_ids"].add(agent_id)
                tasks = read_team_tasks(team_name)
                team_map[team_name] = {"name": team_name, "members": members, "tasks": tasks}
            except Exception:
                pass

    # 2. Supplement with team_session DB table (catches teammates not yet in config files)
    if os.path.exists(db_path):
        try:
            conn = sqlite3.connect(db_path)
            conn.row_factory = sqlite3.Row
            for row in conn.execute("SELECT session_id, team_name, teammate_name FROM team_session"):
                sid, tname, mname = row["session_id"], row["team_name"], row["teammate_name"]
                result["team_session_ids"].add(sid)
                if tname not in team_map:
                    team_map[tname] = {"name": tname, "members": [], "tasks": []}
                # Only add member if not already in list
                existing = {m["session_id"] for m in team_map[tname]["members"]}
                if sid not in existing:
                    team_map[tname]["members"].append({
                        "session_id": sid,
                        "teammate_name": mname,
                        "agent_type": "",
                    })
            conn.close()
        except Exception:
            pass

    # 3. Filter to only teams that have at least one member active
    for team in team_map.values():
        active_members = [m for m in team["members"] if m["session_id"] in active_session_ids]
        if active_members:
            team["members"] = active_members
            result["teams"].append(team)

    return result


# ── FORMATTERS ───────────────────────────────────────────────

def dir_tag(cwd: str) -> str:
    """Return a short [dirname] prefix from a cwd path."""
    if not cwd:
        return ""
    name = os.path.basename(cwd.rstrip("/")) or os.path.basename(os.path.dirname(cwd))
    return f"[{name}]" if name else ""


def find_transcript(agent_id: str) -> str:
    uid = os.getuid()
    for pattern in [
        f"/private/tmp/claude-{uid}/**/tasks/*{agent_id}*.output",
        f"/tmp/claude-{uid}/**/tasks/*{agent_id}*.output",
        os.path.expanduser(f"~/.claude/projects/**/*{agent_id}*.jsonl"),
        os.path.expanduser(f"~/.claude/**/*{agent_id}*.jsonl"),
    ]:
        try:
            matches = glob.glob(pattern, recursive=True)
            if matches:
                return sorted(matches, key=os.path.getmtime, reverse=True)[0]
        except Exception:
            pass
    return ""


_JSONL_FMT = (
    "python3 -u -c \""
    "import sys,json\n"
    "for line in sys.stdin:\n"
    "  try:\n"
    "    e=json.loads(line)\n"
    "    t=e.get('type','')\n"
    "    if t=='assistant':\n"
    "      c=e.get('message',e).get('content',e.get('content',''))\n"
    "      if isinstance(c,list):\n"
    "        txt=''.join(b.get('text','') for b in c if b.get('type')=='text')\n"
    "      else:\n"
    "        txt=str(c)\n"
    "      if txt.strip(): print(txt,flush=True)\n"
    "    elif t=='tool_use':\n"
    "      print(f\\\"  [{e.get('name','')}]\\\",flush=True)\n"
    "  except:pass\n"
    "\""
)


def read_preview_lines(agent: dict, n: int) -> list[str]:
    """Return the last n displayable lines from an agent's output file."""
    transcript = agent.get("transcript_path") or ""
    if not transcript or not os.path.exists(transcript):
        transcript = find_transcript(agent["agent_id"])
    if not transcript or not os.path.exists(transcript):
        return ["(no output yet)"]
    try:
        with open(transcript, "r", errors="replace") as f:
            raw = f.read()
        if transcript.endswith(".jsonl"):
            lines: list[str] = []
            for line in raw.splitlines():
                try:
                    e = json.loads(line)
                    t = e.get("type", "")
                    if t == "assistant":
                        c = e.get("message", e).get("content", e.get("content", ""))
                        txt = "".join(b.get("text", "") for b in c if b.get("type") == "text") if isinstance(c, list) else str(c)
                        lines.extend(ln for ln in txt.splitlines() if ln.strip())
                    elif t == "tool_use":
                        lines.append(f"[{e.get('name', '?')}]")
                except Exception:
                    pass
        else:
            lines = [ln for ln in raw.splitlines() if ln.strip()]
        return lines[-n:] if lines else ["(no output yet)"]
    except Exception as exc:
        return [f"(read error: {exc})"]


def open_agent_in_iterm2(agent: dict) -> str:
    transcript = agent.get("transcript_path") or ""
    if not transcript or not os.path.exists(transcript):
        transcript = find_transcript(agent["agent_id"])
    if not transcript or not os.path.exists(transcript):
        return "no transcript found"

    if transcript.endswith(".jsonl"):
        tail_cmd = f"tail -f '{transcript}' | {_JSONL_FMT}"
    else:
        tail_cmd = f"tail -f '{transcript}'"

    script = f"""tell application "iTerm2"
  tell current window
    create tab with default profile
    tell current session of current tab
      write text "{tail_cmd}"
    end tell
  end tell
end tell"""
    r = subprocess.run(["osascript", "-e", script], capture_output=True, text=True)
    return f"iTerm2: {r.stderr.strip()[:60]}" if r.returncode != 0 else ""



def fmt_dur(start_str: str, end_str: str | None = None) -> str:
    try:
        start = datetime.fromisoformat(start_str).replace(tzinfo=timezone.utc)
        end = datetime.fromisoformat(end_str).replace(tzinfo=timezone.utc) if end_str else datetime.now(timezone.utc)
        secs = max(0, int((end - start).total_seconds()))
        if secs < 60:
            return f"{secs}s"
        m, s = divmod(secs, 60)
        if m < 60:
            return f"{m}m{s:02d}s"
        h, m = divmod(m, 60)
        return f"{h}h{m:02d}m"
    except Exception:
        return "?"


def fmt_time(ts: str | None) -> str:
    if not ts:
        return ""
    try:
        return datetime.fromisoformat(ts).strftime("%H:%M:%S")
    except Exception:
        return "?"


def short_id(s: str) -> str:
    return s[:7] if len(s) > 8 else s


def short_session(s: str) -> str:
    return s[:6] if len(s) > 8 else s


def short_prompt(p: str | None, maxlen: int = 40) -> str:
    if not p:
        return ""
    p = p.replace("\n", " ").strip()
    if p.startswith("<"):
        return ""
    return p[:maxlen] + ".." if len(p) > maxlen else p


def safe_add(stdscr, row: int, col: int, text: str, width: int, attr=0):
    try:
        stdscr.addnstr(row, col, text, max(0, width - col), attr)
    except curses.error:
        pass


# ── BRAILLE GRAPH ────────────────────────────────────────────

def sparkline(buckets, width=10):
    n = width * 2
    vals = ([0] * max(0, n - len(buckets)) + buckets)[-n:]
    mx = max(vals) if vals else 0
    if mx == 0:
        return BRAILLE[0] * width
    norm = [min(4, int(v / mx * 4.99)) if v > 0 else 0 for v in vals]
    return "".join(BRAILLE[norm[i] * 5 + norm[i + 1]] for i in range(0, n, 2))


def _progress_bar(done, in_progress, total, width=5):
    """Build a compact progress bar: █ for done, ▓ for in_progress, ░ for remaining."""
    if total <= 0:
        return "░" * width
    filled = int(done / total * width)
    active = int(in_progress / total * width)
    # Ensure at least 1 char for in_progress if any exist
    if in_progress > 0 and active == 0 and filled < width:
        active = 1
    remaining = width - filled - active
    return "█" * filled + "▓" * active + "░" * max(0, remaining)


def member_status(activity_buckets, session):
    """Return (icon, color) based on member activity."""
    recent = activity_buckets[-5:] if activity_buckets else []
    has_recent_tools = any(b > 0 for b in recent)
    waiting = bool(session.get("lastWaitUserAt"))
    if has_recent_tools:
        return ("◉", GREEN)
    elif waiting:
        return ("○", DIM)
    else:
        return ("◎", YELLOW)


# ── BOX DRAWING ──────────────────────────────────────────────

def draw_box(stdscr, y, x, h, w, title="", title_attr=0, border_attr=0):
    if h < 2 or w < 2:
        return
    ba = border_attr or DIM
    ta = title_attr or CYAN
    top = SYMBOLS["tl"] + SYMBOLS["h"] * (w - 2) + SYMBOLS["tr"]
    if title:
        label = f" {title} "
        if len(label) + 2 < w:
            top = top[:2] + label + top[2 + len(label):]
    safe_add(stdscr, y, x, top, x + w, ba)
    if title:
        safe_add(stdscr, y, x + 2, f" {title} ", x + w, ta)
    for row in range(y + 1, y + h - 1):
        safe_add(stdscr, row, x, SYMBOLS["v"], x + w, ba)
        safe_add(stdscr, row, x + w - 1, SYMBOLS["v"], x + w, ba)
    bot = SYMBOLS["bl"] + SYMBOLS["h"] * (w - 2) + SYMBOLS["br"]
    safe_add(stdscr, y + h - 1, x, bot, x + w, ba)


# ── MAIN DRAW + LOOP ────────────────────────────────────────

def refresh_data(cache: dict) -> dict:
    """Refresh cached dashboard data from DB + filesystem."""
    data = query_db(DB_PATH)
    active_all = data["active_sessions"]
    active_sids_all = {s["session_id"] for s in active_all}
    team_data = query_teams(DB_PATH, active_sids_all)
    cache.update({
        "data": data,
        "active_all": active_all,
        "r_agents": data["running_agents"],
        "c_agents": data["completed_agents"],
        "recent": data["recent_prompts"],
        "tool_events": data["tool_events"],
        "tool_feed": data["tool_feed"],
        "session_tools": data["session_tools"],
        "activity": data["activity"],
        "team_data": team_data,
        "session_lookup": {s["session_id"]: s for s in active_all},
    })
    return cache


def _draw_detail(stdscr, pr, col, max_row, max_col, sel_agent, teams, top_agents, top_tools, cache):
    """Render DETAIL content into a region defined by (pr, col) to (max_row, max_col)."""
    pw = max_col - col  # available width

    def P(r, c, text, attr=0):
        safe_add(stdscr, r, c, text, max_col, attr)

    if sel_agent and sel_agent.get("is_session"):
        # Rich session detail
        sid = sel_agent["session_id"]
        dur = fmt_dur(sel_agent.get("started_at", ""))
        sid_short = sid[:7]
        cwd = sel_agent.get("cwd", "")
        prompt_text = sel_agent.get("prompt", "")
        tag = dir_tag(cwd)
        header = f"{sid_short} \u00b7 {tag} session \u00b7 {dur}" if tag else f"{sid_short} \u00b7 session \u00b7 {dur}"
        P(pr, col, header[:pw], GREEN | curses.A_BOLD)
        pr += 1
        P(pr, col, SYMBOLS["h"] * pw, DIM)
        pr += 1

        # Prompt
        if prompt_text and pr < max_row:
            display_prompt = prompt_text.replace("\n", " ").strip()
            if display_prompt.startswith("<"):
                display_prompt = "(system prompt)"
            P(pr, col, display_prompt[:pw], WHITE)
            pr += 1
            pr += 1

        # Tool event timeline
        session_tools = cache.get("session_tools", {}).get(sid, [])
        if session_tools and pr < max_row - 1:
            P(pr, col, f"TOOLS  {len(session_tools)} recent", CYAN)
            pr += 1
            for ev in session_tools:
                if pr >= max_row:
                    break
                ts = fmt_time(ev.get("created_at"))
                name = ev["tool_name"]
                label = ev["tool_label"]
                tool_str = f"{name}\u2192{label}" if label and label != name else name
                P(pr, col, f"{ts}  {tool_str}", DIM)
                pr += 1
            pr += 1

        # Child agents
        r_agents_list = cache.get("r_agents", [])
        child_agents = [a for a in r_agents_list if a["session_id"] == sid]
        if child_agents and pr < max_row - 1:
            P(pr, col, f"AGENTS  {len(child_agents)} running", CYAN)
            pr += 1
            for a in child_agents:
                if pr >= max_row:
                    break
                adur = fmt_dur(a["started_at"])
                atype = a["agent_type"] or "agent"
                aid = short_id(a["agent_id"])
                P(pr, col, f"\u25b8 {adur:>5}  {atype}  {aid}", MAGENTA)
                pr += 1

    elif sel_agent and sel_agent.get("is_teammate"):
        # Task list for selected team member
        team_name = sel_agent.get("team_name", "")
        teammate_name = sel_agent.get("teammate_name", "")
        dur = fmt_dur(sel_agent.get("started_at", ""))
        sid_short = sel_agent["agent_id"][:7]
        header = f"{sid_short} \u00b7 {team_name}/{teammate_name} \u00b7 {dur}"
        P(pr, col, header[:pw], CYAN | curses.A_BOLD)
        pr += 1
        P(pr, col, SYMBOLS["h"] * pw, DIM)
        pr += 1
        tasks_list = sel_agent.get("_tasks", [])
        sorted_tasks = sorted(
            tasks_list,
            key=lambda t: {"in_progress": 0, "pending": 1, "completed": 2}.get(t.get("status", ""), 1),
        )
        if not sorted_tasks:
            P(pr, col, "(no tasks)", DIM)
        else:
            t_done = sum(1 for t in sorted_tasks if t.get("status") == "completed")
            t_active = sum(1 for t in sorted_tasks if t.get("status") == "in_progress")
            t_blocked = sum(1 for t in sorted_tasks if t.get("status") == "pending" and t.get("blockedBy"))
            t_total = len(sorted_tasks)
            pbar = _progress_bar(t_done, t_active, t_total, 10)
            pct = int(t_done / t_total * 100) if t_total else 0
            parts = [f"{t_done} done"]
            if t_active:
                parts.append(f"{t_active} active")
            if t_blocked:
                parts.append(f"{t_blocked} blocked")
            t_pending_unblocked = t_total - t_done - t_active - t_blocked
            if t_pending_unblocked > 0:
                parts.append(f"{t_pending_unblocked} pending")
            P(pr, col, f"{pbar} {pct}%  {' \u00b7 '.join(parts)}", CYAN)
            pr += 1
            pr += 1  # blank line

            for t in sorted_tasks:
                if pr >= max_row:
                    break
                status = t.get("status", "")
                blocked = bool(t.get("blockedBy")) and status == "pending"
                if status == "completed":
                    icon = "\u2713"
                elif status == "in_progress":
                    icon = "\u25cf"
                elif blocked:
                    icon = "\u2298"
                else:
                    icon = "\u25cb"
                owner = t.get("owner", "")
                owner_tag = f"  [@{owner}]" if owner else ""
                subject = short_prompt(t.get("subject", "?"), pw - 6 - len(owner_tag))
                if status == "completed":
                    attr = DIM
                elif status == "in_progress":
                    attr = YELLOW
                elif blocked:
                    attr = RED
                else:
                    attr = WHITE
                P(pr, col, f"{icon}  {subject}{owner_tag}", attr)
                pr += 1

    elif sel_agent:
        # Live preview of selected subagent
        dur = fmt_dur(sel_agent["started_at"])
        atype = sel_agent.get("agent_type") or "agent"
        aid = sel_agent["agent_id"][:7]
        tag = dir_tag(sel_agent.get("cwd", ""))
        header = f"{aid} \u00b7 {tag} {atype} \u00b7 {dur}" if tag else f"{aid} \u00b7 {atype} \u00b7 {dur}"
        P(pr, col, header[:pw], MAGENTA | curses.A_BOLD)
        pr += 1
        P(pr, col, SYMBOLS["h"] * pw, DIM)
        pr += 1
        for line in read_preview_lines(sel_agent, max_row - pr):
            if pr >= max_row:
                break
            P(pr, col, line[:pw], WHITE)
            pr += 1

    else:
        # Stats view: team metrics, live activity, agent/tool rankings
        def _bar(val: int, max_val: int, bw: int = 8) -> str:
            filled = int(val / max_val * bw) if max_val > 0 else 0
            return "\u2588" * filled + "\u2591" * (bw - filled)

        has_content = False

        # Team metrics
        if teams and pr < max_row - 3:
            for team in teams:
                if pr >= max_row - 1:
                    break
                tl = team["tasks"]
                t_done = sum(1 for t in tl if t.get("status") == "completed")
                t_active = sum(1 for t in tl if t.get("status") == "in_progress")
                t_pending = sum(1 for t in tl if t.get("status") == "pending")
                t_total = len(tl)
                P(pr, col, f"TEAMS  {team['name']}", CYAN)
                pr += 1
                has_content = True
                if t_total > 0:
                    bar = _progress_bar(t_done, t_active, t_total, 10)
                    summary = f"{bar} {t_total} task{'s' if t_total != 1 else ''}  {t_done} done  {t_active} active  {t_pending} pending"
                    P(pr, col, summary, DIM)
                    pr += 1
                pr += 1
                name_w = max((len(m.get("teammate_name", "")) for m in team["members"]), default=0)
                for m in team["members"]:
                    if pr >= max_row:
                        break
                    mname = m.get("teammate_name", "?")
                    m_tasks = [t for t in tl if t.get("owner") == mname]
                    m_done = sum(1 for t in m_tasks if t.get("status") == "completed")
                    m_active = sum(1 for t in m_tasks if t.get("status") == "in_progress")
                    m_total = len(m_tasks)
                    mbar = _progress_bar(m_done, m_active, m_total, 8) if m_total > 0 else "\u2591" * 8
                    task_label = "task" if m_total == 1 else "tasks"
                    P(pr, col, f"{mname.ljust(name_w)}  {m_total} {task_label}  {mbar}", DIM)
                    pr += 1
                pr += 1

        # Agent type rankings (7d)
        if top_agents and pr < max_row - 2:
            P(pr, col, "AGENTS  7d", CYAN)
            pr += 1
            has_content = True
            max_a = top_agents[0]["cnt"]
            tag_w = max((len(dir_tag(e.get("cwd", ""))) for e in top_agents), default=0)
            type_w = max((len(e["agent_type"] or "?") for e in top_agents), default=0)
            for entry in top_agents:
                if pr >= max_row:
                    break
                tag = dir_tag(entry.get("cwd", ""))
                atype = entry["agent_type"] or "?"
                cnt = entry["cnt"]
                bar = _bar(cnt, max_a)
                col1 = tag.ljust(tag_w)
                col2 = atype.ljust(type_w)
                P(pr, col, f"{col1}  {col2}  {bar} {cnt}", DIM)
                pr += 1
            pr += 1

        # Tool rankings (7d)
        if top_tools and pr < max_row - 2:
            P(pr, col, "TOOLS   7d", CYAN)
            pr += 1
            has_content = True
            max_t = top_tools[0]["cnt"]
            ttag_w = max((len(dir_tag(e.get("cwd", ""))) for e in top_tools), default=0)
            tname_w = max((len(e["tool_name"] or "?") for e in top_tools), default=0)
            for entry in top_tools:
                if pr >= max_row:
                    break
                tag = dir_tag(entry.get("cwd", ""))
                tname = entry["tool_name"] or "?"
                cnt = entry["cnt"]
                bar = _bar(cnt, max_t)
                col1 = tag.ljust(ttag_w)
                col2 = tname.ljust(tname_w)
                P(pr, col, f"{col1}  {col2}  {bar} {cnt}", DIM)
                pr += 1

        # Empty state
        if not has_content:
            P(pr, col, "no active sessions", DIM)
            pr += 2
            P(pr, col, "j/k  select agent", DIM)
            pr += 1
            P(pr, col, "esc  deselect", DIM)
            pr += 1
            P(pr, col, "ret  open in iTerm2", DIM)


def draw(stdscr, frame: int, state: dict, cache: dict):
    stdscr.erase()
    h, w = stdscr.getmaxyx()
    if h < 5 or w < 30:
        safe_add(stdscr, 0, 0, "terminal too small", w, 0)
        stdscr.refresh()
        return

    spins = "\u280b\u2819\u2839\u2838\u283c\u2834\u2826\u2827\u2807\u280f"
    sc = spins[frame % len(spins)]
    pulse = ("○", "◎", "●", "◎")[frame % 4]

    active_all = cache["active_all"]
    r_agents = cache["r_agents"]
    c_agents = cache["c_agents"]
    recent = cache["recent"]
    tool_events = cache["tool_events"]
    activity = cache["activity"]
    team_data = cache["team_data"]
    session_lookup = cache["session_lookup"]

    team_session_ids = team_data["team_session_ids"]
    teams = team_data["teams"]

    # Solo sessions: exclude team members (shown in TEAMS section instead)
    active = [s for s in active_all if s["session_id"] not in team_session_ids]

    # Build agents_by_session, track orphans
    active_sids = {s["session_id"] for s in active}
    agents_by_session: dict[str, list[dict]] = {}
    orphan_agents: list[dict] = []
    for a in r_agents:
        if a["session_id"] in active_sids:
            agents_by_session.setdefault(a["session_id"], []).append(a)
        else:
            orphan_agents.append(a)

    # Layout
    split = w >= 100
    lw = (w * 3) // 5 if split else w
    rw = w - lw if split else 0
    rx = lw  # right panel x position

    top_agents = cache["data"].get("top_agents", [])
    top_tools = cache["data"].get("top_tools", [])

    # Helpers: clip to panel widths (preserve box borders)
    def L(r, c, text, attr=0):
        safe_add(stdscr, r, c, text, lw - 1, attr)

    def R(r, c, text, attr=0):
        safe_add(stdscr, r, c, text, rx + rw - 1, attr)

    # Reset visible items for keyboard nav
    visible_items: list[dict] = []

    n_team_members = sum(len(t["members"]) for t in teams)
    total_live = len(active) + len(r_agents) + n_team_members

    # -- Title bar (row 0-1, full width) --
    row = 0
    now = datetime.now(timezone.utc).strftime("%H:%M:%S")
    if total_live > 0:
        title = f" {sc} CLAUDE AGENTS"
        counts = []
        if teams:
            tm_count = n_team_members
            counts.append(f"{len(teams)} team{'s' if len(teams) != 1 else ''} \u00b7 {tm_count} active")
        if active:
            counts.append(f"{len(active)} session{'s' if len(active) != 1 else ''}")
        if r_agents:
            counts.append(f"{len(r_agents)} agent{'s' if len(r_agents) != 1 else ''}")
        count_str = f"  {' \u00b7 '.join(counts)}"
        title_attr = YELLOW
    else:
        title = "   CLAUDE AGENTS"
        count_str = "  idle"
        title_attr = GREEN

    safe_add(stdscr, row, 0, title, w, title_attr)
    safe_add(stdscr, row, len(title), count_str, w, DIM)
    safe_add(stdscr, row, w - len(now) - 1, now, w, DIM)
    row += 1
    safe_add(stdscr, row, 0, SYMBOLS["h"] * w, w, DIM)
    row += 1
    content_top = row

    # -- Compute panel heights --
    # Teams panel
    n_team_subheaders = len(teams) if len(teams) > 1 else 0
    n_active_task_rows = 0
    for team in teams:
        for m in team["members"]:
            if any(t.get("owner") == m.get("teammate_name") and t.get("status") == "in_progress"
                   for t in team["tasks"]):
                n_active_task_rows += 1
    teams_h = (2 + n_team_members + n_active_task_rows + n_team_subheaders) if teams else 0

    # LIVE panel (tool event feed)
    tool_feed = cache.get("tool_feed", [])
    n_feed = min(len(tool_feed), 6)
    live_h = (2 + n_feed) if tool_feed else 0

    # Sessions panel (flat — detail is in the DETAIL panel)
    n_sess_rows = len(active) + len(orphan_agents)
    sess_h = (2 + n_sess_rows) if (active or orphan_agents) else 0

    # History gets remaining space
    hist_h = max(3, h - content_top - teams_h - live_h - sess_h - 1)

    # If nothing active, show a small sessions box with idle message
    if not teams and not active and not r_agents:
        sess_h = 3
        live_h = 0
        hist_h = max(3, h - content_top - sess_h - 1)

    # -- TEAMS panel --
    cr = content_top
    if teams:
        # Build title
        if len(teams) == 1:
            t0 = teams[0]
            tl = t0["tasks"]
            tdone = sum(1 for x in tl if x.get("status") == "completed")
            trinp = sum(1 for x in tl if x.get("status") == "in_progress")
            ttotal = len(tl)
            if ttotal > 0:
                bar = _progress_bar(tdone, trinp, ttotal, 5)
                tcounts = f"  {bar} {tdone}/{ttotal}"
            else:
                tcounts = ""
            box_title = f"TEAMS  {t0['name']}{tcounts}"
        else:
            box_title = f"TEAMS  {len(teams)} teams \u00b7 {n_team_members} active"

        draw_box(stdscr, cr, 0, teams_h, lw, title=box_title)
        tr = cr + 1  # first content row inside box

        for team in teams:
            if tr >= cr + teams_h - 1:
                break
            if len(teams) > 1:
                # Sub-header per team
                tl = team["tasks"]
                tdone = sum(1 for x in tl if x.get("status") == "completed")
                trinp = sum(1 for x in tl if x.get("status") == "in_progress")
                ttotal = len(tl)
                if ttotal > 0:
                    bar = _progress_bar(tdone, trinp, ttotal, 5)
                    tcounts = f"  {bar} {tdone}/{ttotal}"
                else:
                    tcounts = ""
                L(tr, 2, f"\u25c8 {team['name']}{tcounts}", CYAN)
                tr += 1
                base = 4
            else:
                base = 2

            members = team["members"]
            for i, m in enumerate(members):
                if tr >= cr + teams_h - 1:
                    break
                is_last = (i == len(members) - 1)
                connector = "\u2514\u2500" if is_last else "\u251c\u2500"
                sess = session_lookup.get(m["session_id"], {})
                started_at = sess.get("created_at", "")
                dur = fmt_dur(started_at) if started_at else "?"
                teammate_name = m.get("teammate_name") or "teammate"
                sid_short = short_session(m["session_id"])
                item = {
                    "agent_id": m["session_id"],
                    "agent_type": teammate_name,
                    "session_id": m["session_id"],
                    "started_at": started_at,
                    "cwd": sess.get("cwd", ""),
                    "team_name": team["name"],
                    "teammate_name": teammate_name,
                    "is_teammate": True,
                    "_tasks": team["tasks"],
                }
                vidx = len(visible_items)
                visible_items.append(item)
                is_sel = (vidx == state.get("selected", -1))

                # Sparkline + status for this teammate
                spark = sparkline(activity.get(m["session_id"], []))
                s_icon, s_color = member_status(activity.get(m["session_id"], []), sess)

                if is_sel:
                    try:
                        stdscr.addnstr(tr, 1, " " * (lw - 2), lw - 2, SEL_DIM)
                    except curses.error:
                        pass
                    L(tr, base, connector, SEL_DIM)
                    L(tr, base + 3, "\u25b6", SEL_YELLOW)
                    L(tr, base + 5, f"{dur:>5}", SEL_YELLOW)
                    L(tr, base + 11, sid_short, SEL_DIM)
                    L(tr, base + 18, teammate_name, SEL)
                    L(tr, lw - 12, spark, SEL_DIM)
                else:
                    L(tr, base, connector, DIM)
                    L(tr, base + 3, s_icon, s_color)
                    L(tr, base + 5, f"{dur:>5}", YELLOW)
                    L(tr, base + 11, sid_short, DIM)
                    L(tr, base + 18, teammate_name, WHITE)
                    L(tr, lw - 12, spark, CYAN)
                tr += 1

                # Active task row under this member
                active_task = None
                for t in team["tasks"]:
                    if t.get("owner") == teammate_name and t.get("status") == "in_progress":
                        active_task = t
                        break
                if active_task and tr < cr + teams_h - 1:
                    continuation = "\u2502" if not is_last else " "
                    task_text = active_task.get("activeForm") or active_task.get("subject", "")
                    task_text = task_text[:lw - base - 10]
                    if is_sel:
                        try:
                            stdscr.addnstr(tr, 1, " " * (lw - 2), lw - 2, SEL_DIM)
                        except curses.error:
                            pass
                        L(tr, base, continuation, SEL_DIM)
                        L(tr, base + 5, "\u25cf", SEL_YELLOW)
                        L(tr, base + 7, task_text, SEL_YELLOW)
                    else:
                        L(tr, base, continuation, DIM)
                        L(tr, base + 5, "\u25cf", YELLOW)
                        L(tr, base + 7, task_text, YELLOW)
                    tr += 1

        cr += teams_h

    # -- LIVE panel (tool event feed) --
    if tool_feed:
        draw_box(stdscr, cr, 0, live_h, lw, title="LIVE")
        fr = cr + 1
        for ev in tool_feed[:n_feed]:
            if fr >= cr + live_h - 1:
                break
            ts = fmt_time(ev.get("created_at"))
            sid = ev["session_id"]
            # Show [dirname] from the session's cwd for context
            sess_info = session_lookup.get(sid, {})
            tag = dir_tag(sess_info.get("cwd", ""))
            name = ev["tool_name"]
            label = ev["tool_label"]
            tool_str = f"{name}\u2192{label}" if label and label != name else name
            L(fr, 2, ts, DIM)
            if tag:
                L(fr, 11, tag, CYAN)
                L(fr, 11 + len(tag) + 1, tool_str[:lw - 14 - len(tag)], YELLOW)
            else:
                sid_short = short_session(sid)
                L(fr, 11, sid_short, DIM)
                L(fr, 18, tool_str[:lw - 20], YELLOW)
            fr += 1
        cr += live_h

    # -- SESSIONS panel --
    if active or orphan_agents:
        n_running = sum(
            1 for s in active
            if not s.get("lastWaitUserAt") or s["session_id"] in agents_by_session
        )
        n_waiting = len(active) - n_running
        sess_counts = []
        if n_running:
            sess_counts.append(f"{n_running} running")
        if n_waiting:
            sess_counts.append(f"{n_waiting} waiting")
        if r_agents:
            sess_counts.append(f"{len(r_agents)} agent{'s' if len(r_agents) != 1 else ''}")
        sess_title = f"SESSIONS  {' \u00b7 '.join(sess_counts)}" if sess_counts else "SESSIONS"

        draw_box(stdscr, cr, 0, sess_h, lw, title=sess_title)
        sr = cr + 1

        for s in active:
            if sr >= cr + sess_h - 1:
                break
            sid = s["session_id"]
            has_agents = sid in agents_by_session
            waiting = bool(s.get("lastWaitUserAt")) and not has_agents
            sid_short = short_session(sid)
            prompt = short_prompt(s.get("prompt"), max(10, lw - 32))
            spark = sparkline(activity.get(sid, []))

            # Make session selectable
            sess_item = {
                "agent_id": sid,
                "agent_type": "session",
                "session_id": sid,
                "started_at": s["created_at"],
                "cwd": s.get("cwd", ""),
                "is_session": True,
                "prompt": s.get("prompt", ""),
            }
            vidx = len(visible_items)
            visible_items.append(sess_item)
            is_sel = (vidx == state.get("selected", -1))

            if is_sel:
                try:
                    stdscr.addnstr(sr, 1, " " * (lw - 2), lw - 2, SEL_DIM)
                except curses.error:
                    pass
                L(sr, 2, "\u25b6", SEL_YELLOW)
                run_dur = fmt_dur(s["created_at"])
                L(sr, 4, f"{run_dur:>6}", SEL_YELLOW)
                L(sr, 11, sid_short, SEL_DIM)
                L(sr, 18, prompt, SEL)
                L(sr, lw - 12, spark, SEL_DIM)
            elif waiting:
                wait_dur = fmt_dur(s["lastWaitUserAt"])
                L(sr, 2, "\u25cb", YELLOW)
                L(sr, 4, f"~{wait_dur:>5}", DIM)
                L(sr, 11, sid_short, DIM)
                L(sr, 18, prompt, DIM)
            else:
                run_dur = fmt_dur(s["created_at"])
                L(sr, 2, pulse, GREEN)
                L(sr, 4, f"{run_dur:>6}", YELLOW)
                L(sr, 11, sid_short, DIM)
                L(sr, 18, prompt, WHITE)
                L(sr, lw - 12, spark, CYAN)
            sr += 1

        # Orphan agents
        for a in orphan_agents:
            if sr >= cr + sess_h - 1:
                break
            dur = fmt_dur(a["started_at"])
            atype = a["agent_type"] or "agent"
            tag = dir_tag(a.get("cwd", ""))
            vidx = len(visible_items)
            visible_items.append(a)
            is_sel = (vidx == state.get("selected", -1))
            a_spark = sparkline(activity.get(a.get("session_id", ""), []))

            if is_sel:
                try:
                    stdscr.addnstr(sr, 1, " " * (lw - 2), lw - 2, SEL_DIM)
                except curses.error:
                    pass
                L(sr, 2, "\u25b6", SEL_YELLOW)
                L(sr, 4, f"{dur:>6}", SEL_YELLOW)
                col = 11
                if tag:
                    L(sr, col, tag, SEL_CYAN)
                    col += len(tag) + 1
                L(sr, col, atype, SEL)
                L(sr, col + len(atype) + 1, short_id(a["agent_id"]), SEL_DIM)
                L(sr, lw - 12, a_spark, SEL_DIM)
            else:
                L(sr, 2, sc, MAGENTA)
                L(sr, 4, f"{dur:>6}", YELLOW)
                col = 11
                if tag:
                    L(sr, col, tag, CYAN)
                    col += len(tag) + 1
                L(sr, col, atype, MAGENTA)
                L(sr, col + len(atype) + 1, short_id(a["agent_id"]), DIM)
                L(sr, lw - 12, a_spark, CYAN)
            sr += 1

        cr += sess_h

    elif not teams:
        # No active sessions or agents — show idle box
        draw_box(stdscr, cr, 0, sess_h, lw, title="SESSIONS")
        L(cr + 1, 2, "no active sessions or agents", DIM)
        cr += sess_h

    # -- HISTORY or DETAIL-inline panel --
    # When something is selected and terminal is too narrow for side-by-side,
    # show DETAIL in the HISTORY panel's space instead.
    sel_idx = state.get("selected", -1)
    sel_agent = visible_items[sel_idx] if 0 <= sel_idx < len(visible_items) else None
    show_inline_detail = sel_agent is not None and not split

    if show_inline_detail:
        draw_box(stdscr, cr, 0, hist_h, lw, title="DETAIL")
        _draw_detail(stdscr, cr + 1, 2, cr + hist_h - 1, lw - 1,
                     sel_agent, teams, top_agents, top_tools, cache)
    else:
        draw_box(stdscr, cr, 0, hist_h, lw, title="HISTORY")
        hr = cr + 1

        history = []
        for a in c_agents:
            history.append(("agent", a["stopped_at"], a))
        for s in recent:
            history.append(("prompt", s["stoped_at"], s))
        history.sort(key=lambda x: x[1] or "", reverse=True)

        if not history:
            L(hr, 2, "(empty)", DIM)
        else:
            shown = 0
            for kind, ts, item in history:
                if hr >= cr + hist_h - 1 or shown >= MAX_HISTORY:
                    break
                t = fmt_time(ts)
                if kind == "agent":
                    dur = fmt_dur(item["started_at"], item["stopped_at"])
                    atype = item.get("agent_type") or "agent"
                    L(hr, 2, t, DIM)
                    L(hr, 11, f"{dur:>6}", DIM)
                    L(hr, 18, f"\u25b8 {atype}", curses.color_pair(6))
                else:
                    dur = fmt_dur(item["created_at"], item["stoped_at"])
                    prompt = short_prompt(item.get("prompt"), max(10, lw - 21))
                    if not prompt:
                        continue
                    L(hr, 2, t, DIM)
                    L(hr, 11, f"{dur:>6}", DIM)
                    L(hr, 18, prompt, DIM)
                hr += 1
                shown += 1

    # Clamp selection to visible items
    state["visible_items"] = visible_items
    if visible_items:
        state["selected"] = max(-1, min(state.get("selected", -1), len(visible_items) - 1))
    else:
        state["selected"] = -1

    # -- DETAIL panel (right side, or inline above) --
    if split and rw > 10:
        detail_h = h - content_top - 1
        draw_box(stdscr, content_top, rx, detail_h, rw, title="DETAIL")
        _draw_detail(stdscr, content_top + 1, rx + 2, content_top + detail_h - 1, rx + rw - 1,
                     sel_agent, teams, top_agents, top_tools, cache)

    # -- Footer (full width) --
    status = state.get("status_msg", "")
    if status and time.time() < state.get("status_until", 0):
        safe_add(stdscr, h - 1, 0, f" {status}", w, YELLOW)
    elif visible_items:
        safe_add(stdscr, h - 1, 0, " j/k=select  esc=deselect  enter=open  q=quit", w, DIM)
    else:
        safe_add(stdscr, h - 1, 0, " q=quit", w, DIM)
    stdscr.refresh()


RENDER_MS = 200     # redraw interval (smooth animations)
DATA_FRAMES = 10    # refresh DB every N frames (~2s at 200ms)


def main(stdscr):
    curses.curs_set(0)
    stdscr.nodelay(True)
    stdscr.timeout(RENDER_MS)
    stdscr.keypad(True)

    init_colors()

    state: dict = {"selected": -1, "visible_items": [], "status_msg": "", "status_until": 0.0}
    cache: dict = {}
    refresh_data(cache)
    frame = 0
    while True:
        if frame % DATA_FRAMES == 0:
            refresh_data(cache)
        draw(stdscr, frame, state, cache)
        frame += 1
        ch = stdscr.getch()
        if ch in (ord("q"), ord("Q")):
            break
        elif ch == 27:  # Esc — deselect (back to stats view)
            state["selected"] = -1
        elif ch in (ord("j"), curses.KEY_DOWN):
            agents = state["visible_items"]
            if agents:
                state["selected"] = min(state["selected"] + 1, len(agents) - 1) if state["selected"] >= 0 else 0
        elif ch in (ord("k"), curses.KEY_UP):
            if state["selected"] > 0:
                state["selected"] -= 1
        elif ch in (10, 13, curses.KEY_ENTER):
            idx = state["selected"]
            agents = state["visible_items"]
            if 0 <= idx < len(agents):
                item = agents[idx]
                # Only agents have transcripts to open
                if not item.get("is_session") and not item.get("is_teammate"):
                    short = item["agent_id"][:7]
                    curses.def_prog_mode()
                    curses.endwin()
                    try:
                        err = open_agent_in_iterm2(item)
                        atype = (item.get("agent_type") or "agent")[:12]
                        state["status_msg"] = err if err else f"opened tab: {atype}-{short}"
                    finally:
                        stdscr.refresh()
                        curses.reset_prog_mode()
                    state["status_until"] = time.time() + 3


def self_update():
    """Pull latest from GitHub and replace the running script."""
    import urllib.request
    raw_url = "https://raw.githubusercontent.com/kingsotn-twelve/claude-agents/main/claude-agents"
    try:
        with urllib.request.urlopen(raw_url, timeout=10) as resp:
            new_src = resp.read().decode()
    except Exception as e:
        print(f"update failed: {e}")
        sys.exit(1)
    # Extract remote version
    remote_ver = None
    for line in new_src.splitlines()[:30]:
        if line.startswith("VERSION"):
            remote_ver = line.split('"')[1]
            break
    if remote_ver == VERSION:
        print(f"already up to date (v{VERSION})")
        return
    # Overwrite self
    me = os.path.realpath(sys.argv[0])
    try:
        with open(me, "w") as f:
            f.write(new_src)
        print(f"updated v{VERSION} → v{remote_ver}")
    except Exception as e:
        print(f"write failed: {e}")
        sys.exit(1)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog="claude-agents",
        description="Live terminal dashboard for Claude Code sessions & agents.\n"
                    "Tree view: agents nested under sessions, tool feed for agentless sessions.\n"
                    "Run in a separate pane alongside Claude Code.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "--version", action="version", version=f"claude-agents v{VERSION}"
    )
    parser.add_argument(
        "--update", action="store_true", help="self-update from GitHub"
    )
    args = parser.parse_args()

    if args.update:
        self_update()
        sys.exit(0)

    try:
        curses.wrapper(main)
    except KeyboardInterrupt:
        pass
