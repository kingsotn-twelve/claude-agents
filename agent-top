#!/usr/bin/env python3
"""
agent-top — live terminal dashboard for Claude Code sessions & agents.
btop-style TUI with rounded box panels, braille sparklines, and tree views.
Run in a separate pane: agent-top
"""

import argparse
import curses
import glob
import random
import json
import os
import sqlite3
import subprocess
import sys
import time
from datetime import datetime, timezone

VERSION = "0.9.2"

PREVIEW_ROWS = 7  # lines reserved for inline preview (divider + header + content)

DB_PATH = os.environ.get("AGENT_TOP_DB") or os.path.expanduser("~/.claude/ccnotify/ccnotify.db")

MAX_COMPLETED_AGENTS = 10
MAX_HISTORY = 20
MAX_TOOL_EVENTS = 3  # tools shown per agentless session

# ── CONSTANTS & SYMBOLS ──────────────────────────────────────

SYMBOLS = {"tl": "╭", "tr": "╮", "bl": "╰", "br": "╯", "h": "─", "v": "│", "lt": "├", "rt": "┤"}
BRAILLE = "⠀⠂⠄⠆⠈⠐⠒⠔⠖⠘⠠⠢⠤⠦⠨⠰⠲⠴⠶⠸⡀⡂⡄⡆⡈"

GREEN = CYAN = YELLOW = DIM = MAGENTA = WHITE = RED = 0

# ── TOOL NAME MAPPING ───────────────────────────────────────

TOOL_NAMES = {
    "Read": "Read file",
    "Write": "Write file",
    "Edit": "Edit file",
    "Bash": "Run command",
    "Grep": "Search code",
    "Glob": "Find files",
    "WebFetch": "Fetch URL",
    "WebSearch": "Web search",
    "AskUserQuestion": "Ask user",
    "TaskCreate": "Create task",
    "TaskUpdate": "Update task",
    "TaskList": "List tasks",
    "TaskGet": "Get task",
    "EnterWorktree": "Create worktree",
    "EnterPlanMode": "Enter plan mode",
    "ExitPlanMode": "Exit plan mode",
    "NotebookEdit": "Edit notebook",
    "SendMessage": "Send message",
    "TeamCreate": "Create team",
    "Task": "Spawn agent",
    "Skill": "Run skill",
}

VIZ_MODES = ["tree", "gantt"]
VIZ_LABELS = {"tree": "TREE", "gantt": "TIMELINE"}


def friendly_tool(name: str, label: str = "") -> str:
    """Return human-readable tool description."""
    base = TOOL_NAMES.get(name, "")
    # Handle MCP tools: mcp__server__method → Server: method
    if not base and name.startswith("mcp__"):
        parts = name.split("__")
        if len(parts) >= 3:
            server = parts[1].replace("claude_ai_", "").replace("_", " ").title()
            method = parts[2].replace("_", " ")
            base = f"{server}: {method}"
    if not base:
        base = name
    if label and label != name:
        # Shorten paths in labels
        short_label = label
        if "/" in short_label:
            short_label = os.path.basename(short_label)
        return f"{base}: {short_label}"
    return base
# Selection highlight variants (white-on-dark-gray)
SEL = SEL_DIM = SEL_CYAN = SEL_YELLOW = SEL_GREEN = SEL_MAGENTA = 0
BG_SEL = 236  # dark gray background


def init_colors():
    global GREEN, CYAN, YELLOW, DIM, MAGENTA, WHITE, RED
    global SEL, SEL_DIM, SEL_CYAN, SEL_YELLOW, SEL_GREEN, SEL_MAGENTA, BG_SEL
    curses.start_color()
    curses.use_default_colors()
    # Normal colors (pair 1-7)
    for i, c in enumerate([curses.COLOR_GREEN, curses.COLOR_WHITE, curses.COLOR_CYAN,
                           curses.COLOR_YELLOW, 8, curses.COLOR_MAGENTA, curses.COLOR_RED], 1):
        curses.init_pair(i, c, -1)
    GREEN = curses.color_pair(1) | curses.A_BOLD
    WHITE = curses.color_pair(2)
    CYAN = curses.color_pair(3) | curses.A_BOLD
    YELLOW = curses.color_pair(4) | curses.A_BOLD
    DIM = curses.color_pair(5)
    MAGENTA = curses.color_pair(6) | curses.A_BOLD
    RED = curses.color_pair(7) | curses.A_BOLD
    # Selection highlight colors (pair 11-16: foreground on dark gray)
    try:
        curses.init_pair(11, curses.COLOR_WHITE, BG_SEL)
        curses.init_pair(12, 8, BG_SEL)  # dim on dark gray
        curses.init_pair(13, curses.COLOR_CYAN, BG_SEL)
        curses.init_pair(14, curses.COLOR_YELLOW, BG_SEL)
        curses.init_pair(15, curses.COLOR_GREEN, BG_SEL)
        curses.init_pair(16, curses.COLOR_MAGENTA, BG_SEL)
        SEL = curses.color_pair(11) | curses.A_BOLD
        SEL_DIM = curses.color_pair(12)
        SEL_CYAN = curses.color_pair(13) | curses.A_BOLD
        SEL_YELLOW = curses.color_pair(14) | curses.A_BOLD
        SEL_GREEN = curses.color_pair(15) | curses.A_BOLD
        SEL_MAGENTA = curses.color_pair(16) | curses.A_BOLD
    except curses.error:
        # Fallback if terminal doesn't support 256 colors
        SEL = curses.A_REVERSE | curses.A_BOLD
        SEL_DIM = curses.A_REVERSE
        SEL_CYAN = curses.A_REVERSE | curses.A_BOLD
        SEL_YELLOW = curses.A_REVERSE | curses.A_BOLD
        SEL_GREEN = curses.A_REVERSE | curses.A_BOLD
        SEL_MAGENTA = curses.A_REVERSE | curses.A_BOLD


# ── DATA QUERIES ─────────────────────────────────────────────

STATS_RANGES = [
    ("1h", "-1 hours"),
    ("1d", "-1 days"),
    ("7d", "-7 days"),
    ("30d", "-30 days"),
    ("all", None),
]


def query_db(db_path: str, stats_range_idx: int = 2) -> dict:
    data = {
        "active_sessions": [],
        "running_agents": [],
        "completed_agents": [],
        "recent_prompts": [],
        "tool_events": {},  # session_id -> [{tool_name, tool_label}]
        "session_tools": {},  # session_id -> [{tool_name, tool_label, created_at}] — extended list for detail view
        "top_agents": [],
        "top_tools": [],
        "activity": {},
    }
    if not os.path.exists(db_path):
        return data

    try:
        conn = sqlite3.connect(db_path)
        conn.row_factory = sqlite3.Row

        # Active sessions: latest prompt per session.
        # A session is "active" if un-stopped AND one of:
        #   - has lastWaitUserAt set (terminal is open, waiting for input — no time limit)
        #   - had tool activity in the last 30 min (actively running)
        #   - created within the last 5 min (grace period before first tool call)
        # Sessions only disappear when Stop fires (terminal closed) or ghost detection (no
        # lastWaitUserAt and no recent tools = probably killed without Stop).
        for row in conn.execute(
            """SELECT p.session_id, p.prompt, p.cwd, p.created_at, p.seq, p.lastWaitUserAt
               FROM prompt p
               INNER JOIN (
                   SELECT session_id, MAX(id) as max_id
                   FROM prompt
                   WHERE stoped_at IS NULL
                     AND (
                       lastWaitUserAt IS NOT NULL
                       OR created_at > datetime('now', '-5 minutes')
                       OR session_id IN (
                         SELECT DISTINCT session_id FROM tool_event
                         WHERE created_at > datetime('now', '-30 minutes')
                       )
                     )
                   GROUP BY session_id
               ) latest ON p.id = latest.max_id
               ORDER BY p.created_at DESC
               LIMIT 10"""
        ):
            data["active_sessions"].append(dict(row))

        # Reap orphaned agents: parent session has no open prompt rows (stoped_at IS NOT NULL
        # on all its prompts), meaning Claude fired the Stop hook and the session is truly gone.
        # This avoids reaping agents for sessions that are open but idle.
        # Grace period of 5 min covers agents whose session just started.
        conn.execute(
            """UPDATE agent SET stopped_at = datetime('now')
               WHERE stopped_at IS NULL
                 AND started_at < datetime('now', '-5 minutes')
                 AND session_id NOT IN (
                     SELECT DISTINCT session_id FROM prompt WHERE stoped_at IS NULL
                 )"""
        )
        conn.commit()

        # Running agents (skip ghosts with empty type)
        for row in conn.execute(
            """SELECT agent_id, agent_type, session_id, cwd, started_at, transcript_path
               FROM agent
               WHERE stopped_at IS NULL
               ORDER BY started_at ASC"""
        ):
            data["running_agents"].append(dict(row))

        # Completed agents (skip ghosts)
        for row in conn.execute(
            f"""SELECT agent_id, agent_type, session_id, cwd, started_at, stopped_at, transcript_path
                FROM agent
                WHERE stopped_at IS NOT NULL
                ORDER BY stopped_at DESC
                LIMIT {MAX_COMPLETED_AGENTS}"""
        ):
            data["completed_agents"].append(dict(row))

        # Recent completed prompts (skip system/task-notification noise)
        for row in conn.execute(
            f"""SELECT session_id, prompt, cwd, created_at, stoped_at, seq
                FROM prompt
                WHERE stoped_at IS NOT NULL
                  AND prompt NOT LIKE '<%'
                ORDER BY stoped_at DESC
                LIMIT {MAX_HISTORY}"""
        ):
            data["recent_prompts"].append(dict(row))

        # Tool events: last N per active session, within last 10 min
        active_sids = [s["session_id"] for s in data["active_sessions"]]
        for sid in active_sids:
            tools = []
            for row in conn.execute(
                """SELECT tool_name, tool_label FROM tool_event
                   WHERE session_id = ?
                     AND created_at > datetime('now', '-10 minutes')
                   ORDER BY created_at DESC
                   LIMIT ?""",
                (sid, MAX_TOOL_EVENTS),
            ):
                tools.append(dict(row))
            if tools:
                # Reverse so oldest is first (left-to-right reading)
                data["tool_events"][sid] = list(reversed(tools))

        # Session tools: extended tool list per active session (for DETAIL view)
        for sid in active_sids:
            try:
                rows = []
                for row in conn.execute(
                    """SELECT tool_name, tool_label, created_at FROM tool_event
                       WHERE session_id = ?
                         AND created_at > datetime('now', '-30 minutes')
                       ORDER BY created_at DESC
                       LIMIT 20""",
                    (sid,),
                ):
                    rows.append(dict(row))
                if rows:
                    data["session_tools"][sid] = list(reversed(rows))
            except sqlite3.OperationalError:
                pass

        # Activity buckets for sparklines (last 60s, 20 buckets of 3s each)
        for sid in active_sids:
            try:
                rows = conn.execute(
                    "SELECT created_at FROM tool_event WHERE session_id = ? AND created_at > datetime('now', '-60 seconds')",
                    (sid,)).fetchall()
                buckets = [0] * 20
                now_utc = datetime.now(timezone.utc)
                for (ts_str,) in rows:
                    try:
                        ts = datetime.fromisoformat(ts_str).replace(tzinfo=timezone.utc)
                        age = (now_utc - ts).total_seconds()
                        slot = int(age / 3)
                        if 0 <= slot < 20:
                            buckets[19 - slot] += 1
                    except Exception:
                        pass
                data["activity"][sid] = buckets
            except Exception:
                pass

        # Usage stats: top agent types + top tools
        _, sql_interval = STATS_RANGES[stats_range_idx]
        if sql_interval:
            agent_where = f"WHERE started_at > datetime('now', '{sql_interval}') AND agent_type != ''"
            tool_where = f"WHERE te.created_at > datetime('now', '{sql_interval}')"
        else:
            agent_where = "WHERE agent_type != ''"
            tool_where = ""
        try:
            data["top_agents"] = [
                dict(r) for r in conn.execute(
                    f"""SELECT agent_type, cwd, COUNT(*) as cnt FROM agent
                       {agent_where}
                       GROUP BY agent_type, cwd ORDER BY cnt DESC LIMIT 12"""
                )
            ]
        except sqlite3.OperationalError:
            data["top_agents"] = []
        try:
            data["top_tools"] = [
                dict(r) for r in conn.execute(
                    f"""SELECT te.tool_name, p.cwd, COUNT(*) as cnt
                       FROM tool_event te
                       LEFT JOIN prompt p ON te.session_id = p.session_id
                       {tool_where}
                       GROUP BY te.tool_name, p.cwd ORDER BY cnt DESC LIMIT 12"""
                )
            ]
        except sqlite3.OperationalError:
            data["top_tools"] = []

        conn.close()
    except sqlite3.OperationalError:
        pass

    return data


def read_team_tasks(team_name: str) -> list[dict]:
    """Read task JSON files from ~/.claude/tasks/{team_name}/."""
    tasks_dir = os.path.expanduser(f"~/.claude/tasks/{team_name}")
    if not os.path.isdir(tasks_dir):
        return []
    tasks = []
    try:
        for path in glob.glob(os.path.join(tasks_dir, "*.json")):
            try:
                with open(path, "r", errors="replace") as f:
                    obj = json.load(f)
                if isinstance(obj, dict) and "status" in obj and "subject" in obj:
                    tasks.append(obj)
                elif isinstance(obj, list):
                    # Some implementations store all tasks in one file
                    for item in obj:
                        if isinstance(item, dict) and "status" in item and "subject" in item:
                            tasks.append(item)
            except Exception:
                pass
    except Exception:
        pass
    return tasks


def query_teams(db_path: str, active_session_ids: set[str]) -> dict:
    """Read team config files + task files; supplement with team_session DB table."""
    result: dict = {"teams": [], "team_session_ids": set()}
    teams_root = os.path.expanduser("~/.claude/teams")
    team_map: dict[str, dict] = {}  # team_name -> {name, members, tasks}

    # 1. Read file-system team configs
    if os.path.isdir(teams_root):
        for config_path in glob.glob(os.path.join(teams_root, "*/config.json")):
            try:
                with open(config_path, "r", errors="replace") as f:
                    cfg = json.load(f)
                team_name = cfg.get("name") or os.path.basename(os.path.dirname(config_path))
                members = []
                for m in cfg.get("members", []):
                    agent_id = m.get("agentId", "")
                    if agent_id:
                        members.append({
                            "session_id": agent_id,
                            "teammate_name": m.get("name", ""),
                            "agent_type": m.get("agentType", ""),
                        })
                        result["team_session_ids"].add(agent_id)
                tasks = read_team_tasks(team_name)
                team_map[team_name] = {"name": team_name, "members": members, "tasks": tasks}
            except Exception:
                pass

    # 2. Supplement with team_session DB table (catches teammates not yet in config files)
    if os.path.exists(db_path):
        try:
            conn = sqlite3.connect(db_path)
            conn.row_factory = sqlite3.Row
            for row in conn.execute("SELECT session_id, team_name, teammate_name FROM team_session"):
                sid, tname, mname = row["session_id"], row["team_name"], row["teammate_name"]
                result["team_session_ids"].add(sid)
                if tname not in team_map:
                    team_map[tname] = {"name": tname, "members": [], "tasks": []}
                # Only add member if not already in list
                existing = {m["session_id"] for m in team_map[tname]["members"]}
                if sid not in existing:
                    team_map[tname]["members"].append({
                        "session_id": sid,
                        "teammate_name": mname,
                        "agent_type": "",
                    })
            conn.close()
        except Exception:
            pass

    # 3. Filter to only teams that have at least one member active
    for team in team_map.values():
        active_members = [m for m in team["members"] if m["session_id"] in active_session_ids]
        if active_members:
            team["members"] = active_members
            result["teams"].append(team)

    return result


# ── FORMATTERS ───────────────────────────────────────────────

def dir_tag(cwd: str) -> str:
    """Return a short [dirname] prefix from a cwd path."""
    if not cwd:
        return ""
    name = os.path.basename(cwd.rstrip("/")) or os.path.basename(os.path.dirname(cwd))
    return f"[{name}]" if name else ""


def find_transcript(agent_id: str) -> str:
    uid = os.getuid()
    for pattern in [
        f"/private/tmp/claude-{uid}/**/tasks/*{agent_id}*.output",
        f"/tmp/claude-{uid}/**/tasks/*{agent_id}*.output",
        os.path.expanduser(f"~/.claude/projects/**/*{agent_id}*.jsonl"),
        os.path.expanduser(f"~/.claude/**/*{agent_id}*.jsonl"),
    ]:
        try:
            matches = glob.glob(pattern, recursive=True)
            if matches:
                return sorted(matches, key=os.path.getmtime, reverse=True)[0]
        except Exception:
            pass
    return ""


_JSONL_FMT = (
    "python3 -u -c \""
    "import sys,json\n"
    "for line in sys.stdin:\n"
    "  try:\n"
    "    e=json.loads(line)\n"
    "    t=e.get('type','')\n"
    "    if t=='assistant':\n"
    "      c=e.get('message',e).get('content',e.get('content',''))\n"
    "      if isinstance(c,list):\n"
    "        txt=''.join(b.get('text','') for b in c if b.get('type')=='text')\n"
    "      else:\n"
    "        txt=str(c)\n"
    "      if txt.strip(): print(txt,flush=True)\n"
    "    elif t=='tool_use':\n"
    "      print(f\\\"  [{e.get('name','')}]\\\",flush=True)\n"
    "  except:pass\n"
    "\""
)


def read_preview_lines(agent: dict, n: int) -> list[str]:
    """Return the last n displayable lines from an agent's output file."""
    transcript = agent.get("transcript_path") or ""
    if not transcript or not os.path.exists(transcript):
        transcript = find_transcript(agent["agent_id"])
    if not transcript or not os.path.exists(transcript):
        return ["(no output yet)"]
    try:
        with open(transcript, "r", errors="replace") as f:
            raw = f.read()
        if transcript.endswith(".jsonl"):
            lines: list[str] = []
            for line in raw.splitlines():
                try:
                    e = json.loads(line)
                    t = e.get("type", "")
                    if t == "assistant":
                        c = e.get("message", e).get("content", e.get("content", ""))
                        txt = "".join(b.get("text", "") for b in c if b.get("type") == "text") if isinstance(c, list) else str(c)
                        lines.extend(ln for ln in txt.splitlines() if ln.strip())
                    elif t == "tool_use":
                        lines.append(f"[{e.get('name', '?')}]")
                except Exception:
                    pass
        else:
            lines = [ln for ln in raw.splitlines() if ln.strip()]
        return lines[-n:] if lines else ["(no output yet)"]
    except Exception as exc:
        return [f"(read error: {exc})"]


def open_agent_in_iterm2(agent: dict) -> str:
    transcript = agent.get("transcript_path") or ""
    if not transcript or not os.path.exists(transcript):
        transcript = find_transcript(agent["agent_id"])
    if not transcript or not os.path.exists(transcript):
        return "no transcript found"

    if transcript.endswith(".jsonl"):
        tail_cmd = f"tail -f '{transcript}' | {_JSONL_FMT}"
    else:
        tail_cmd = f"tail -f '{transcript}'"

    script = f"""tell application "iTerm2"
  tell current window
    create tab with default profile
    tell current session of current tab
      write text "{tail_cmd}"
    end tell
  end tell
end tell"""
    r = subprocess.run(["osascript", "-e", script], capture_output=True, text=True)
    return f"iTerm2: {r.stderr.strip()[:60]}" if r.returncode != 0 else ""



def fmt_dur(start_str: str, end_str: str | None = None) -> str:
    try:
        start = datetime.fromisoformat(start_str).replace(tzinfo=timezone.utc)
        end = datetime.fromisoformat(end_str).replace(tzinfo=timezone.utc) if end_str else datetime.now(timezone.utc)
        secs = max(0, int((end - start).total_seconds()))
        if secs < 60:
            return f"{secs}s"
        m, s = divmod(secs, 60)
        if m < 60:
            return f"{m}m{s:02d}s"
        h, m = divmod(m, 60)
        return f"{h}h{m:02d}m"
    except Exception:
        return "?"


def fmt_time(ts: str | None) -> str:
    if not ts:
        return ""
    try:
        return datetime.fromisoformat(ts).strftime("%H:%M:%S")
    except Exception:
        return "?"


def short_id(s: str) -> str:
    return s[:7] if len(s) > 8 else s


def short_session(s: str) -> str:
    return s[:6] if len(s) > 8 else s


def short_prompt(p: str | None, maxlen: int = 40) -> str:
    if not p:
        return ""
    p = p.replace("\n", " ").strip()
    if p.startswith("<"):
        return ""
    return p[:maxlen] + ".." if len(p) > maxlen else p


def safe_add(stdscr, row: int, col: int, text: str, width: int, attr=0):
    try:
        stdscr.addnstr(row, col, text, max(0, width - col), attr)
    except curses.error:
        pass


# ── BRAILLE GRAPH ────────────────────────────────────────────

def sparkline(buckets, width=10):
    n = width * 2
    vals = ([0] * max(0, n - len(buckets)) + buckets)[-n:]
    mx = max(vals) if vals else 0
    if mx == 0:
        return BRAILLE[0] * width
    norm = [min(4, int(v / mx * 4.99)) if v > 0 else 0 for v in vals]
    return "".join(BRAILLE[norm[i] * 5 + norm[i + 1]] for i in range(0, n, 2))


# ── GAME OF LIFE ─────────────────────────────────────────────

def life_init(rows, cols, density=0.3):
    """Random seed for Game of Life grid."""
    return [[random.random() < density for _ in range(cols)] for _ in range(rows)]


def life_step(grid, rows, cols):
    """One generation of Conway's Game of Life (toroidal, optimized)."""
    new = [[False] * cols for _ in range(rows)]
    for r in range(rows):
        rm = (r - 1) % rows
        rp = (r + 1) % rows
        row_m, row_0, row_p = grid[rm], grid[r], grid[rp]
        for c in range(cols):
            cm = (c - 1) % cols
            cp = (c + 1) % cols
            n = row_m[cm] + row_m[c] + row_m[cp] + row_0[cm] + row_0[cp] + row_p[cm] + row_p[c] + row_p[cp]
            if n == 3 or (n == 2 and row_0[c]):
                new[r][c] = True
    return new


def life_render(grid, rows, cols, char_w, char_h):
    """Render grid as list of [(char, density), ...] per row. Density 0-8 = alive dots per braille cell."""
    lines = []
    for cy in range(char_h):
        row = []
        for cx in range(char_w):
            code = 0x2800
            alive = 0
            for dy in range(4):
                for dx in range(2):
                    gr, gc = cy * 4 + dy, cx * 2 + dx
                    if gr < rows and gc < cols and grid[gr][gc]:
                        alive += 1
                        if dx == 0:
                            code |= 1 << [0, 1, 2, 6][dy]
                        else:
                            code |= 1 << [3, 4, 5, 7][dy]
            row.append((chr(code), alive))
        lines.append(row)
    return lines


# ── VISUALIZATION MODES ──────────────────────────────────────

def _draw_viz_gantt(stdscr, y, x, h, w, cache, state):
    """Timeline Gantt: horizontal bars showing duration + parallelism."""
    active_all = cache.get("active_all", [])
    r_agents = cache.get("r_agents", [])
    c_agents = cache.get("c_agents", [])
    rw_abs = x + w - 1

    # Pick session scope
    vis = state.get("visible_items", [])
    sel = state.get("selected", -1)
    sel_item = vis[sel] if 0 <= sel < len(vis) else None
    target_sid = sel_item.get("session_id", "") if sel_item else ""
    if not target_sid and active_all:
        target_sid = active_all[0]["session_id"]

    # Collect tracks for this session
    tracks = []
    sess = next((s for s in active_all if s["session_id"] == target_sid), None)
    if sess:
        tracks.append({"label": short_prompt(sess.get("prompt", ""), 12) or target_sid[:6],
                       "type": "session", "started_at": sess["created_at"], "stopped_at": None})
    for a in r_agents:
        if a["session_id"] == target_sid:
            tracks.append({"label": (a["agent_type"] or "agent")[:12], "type": "agent",
                           "started_at": a["started_at"], "stopped_at": None})
    for a in c_agents[:8]:
        if a["session_id"] == target_sid:
            tracks.append({"label": (a["agent_type"] or "agent")[:12], "type": "completed",
                           "started_at": a["started_at"], "stopped_at": a.get("stopped_at")})

    if not tracks:
        safe_add(stdscr, y + 1, x + 2, "select a session", rw_abs, DIM)
        return

    # Compute time range from earliest start to now
    now_utc = datetime.now(timezone.utc)
    try:
        earliest = min(datetime.fromisoformat(t["started_at"]).replace(tzinfo=timezone.utc) for t in tracks)
    except Exception:
        earliest = now_utc
    span = max(1.0, (now_utc - earliest).total_seconds())

    label_w = 14
    bar_w = w - label_w - 4
    if bar_w < 5:
        return

    pr = y
    type_colors = {"session": GREEN, "agent": MAGENTA, "completed": DIM}

    for track in tracks:
        if pr >= y + h - 1:
            break
        color = type_colors.get(track["type"], DIM)
        label = track["label"][:label_w].ljust(label_w)
        safe_add(stdscr, pr, x + 2, label, rw_abs, color)

        # Compute bar position
        try:
            t_start = datetime.fromisoformat(track["started_at"]).replace(tzinfo=timezone.utc)
            t_end = datetime.fromisoformat(track["stopped_at"]).replace(tzinfo=timezone.utc) if track["stopped_at"] else now_utc
            start_frac = max(0.0, (t_start - earliest).total_seconds() / span)
            end_frac = min(1.0, (t_end - earliest).total_seconds() / span)
        except Exception:
            start_frac, end_frac = 0.0, 1.0

        bar_start = int(start_frac * bar_w)
        bar_end = max(bar_start + 1, int(end_frac * bar_w))

        # Build the bar: spaces before, blocks during, spaces after
        bar = "\u2591" * bar_start + "\u2588" * (bar_end - bar_start) + "\u2591" * (bar_w - bar_end)
        safe_add(stdscr, pr, x + label_w + 2, bar[:bar_w], rw_abs, color)

        # Duration label at end of bar
        dur = fmt_dur(track["started_at"], track["stopped_at"])
        safe_add(stdscr, pr, x + label_w + 2 + bar_end + 1, dur, rw_abs, DIM)
        pr += 1

    # Time axis
    if pr < y + h:
        if span < 120:
            axis_label = f"{'0s':<{bar_w // 2}}{fmt_dur(tracks[0]['started_at']):>{bar_w // 2}}"
        else:
            axis_label = f"{'start':<{bar_w // 2}}{'now':>{bar_w // 2}}"
        safe_add(stdscr, pr, x + label_w + 2, axis_label[:bar_w], rw_abs, DIM)


def _draw_viz_tree(stdscr, y, x, h, w, cache, state):
    """Hierarchical Tree: selected session's agents + tool timeline."""
    active_all = cache.get("active_all", [])
    r_agents = cache.get("r_agents", [])
    c_agents = cache.get("c_agents", [])
    session_tools = cache.get("session_tools", {})
    tool_events = cache.get("tool_events", {})
    rw = x + w  # absolute right edge

    # Scope to selected session
    vis = state.get("visible_items", [])
    sel = state.get("selected", -1)
    sel_item = vis[sel] if 0 <= sel < len(vis) else None
    target_sid = sel_item.get("session_id", "") if sel_item else ""
    if not target_sid and active_all:
        target_sid = active_all[0]["session_id"]
    if not target_sid:
        safe_add(stdscr, y, x + 2, "select a session", rw, DIM)
        return

    pr = y

    # Named agents (with non-empty type) for this session
    children = [a for a in r_agents if a["session_id"] == target_sid and a.get("agent_type")]
    completed = [a for a in c_agents if a["session_id"] == target_sid and a.get("agent_type")][:5]
    named_agents = children + completed
    if named_agents:
        safe_add(stdscr, pr, x + 2, f"AGENTS  {len(named_agents)}", rw, CYAN)
        pr += 1
        for i, a in enumerate(named_agents):
            if pr >= y + h:
                break
            is_last = (i == len(named_agents) - 1)
            connector = "\u2514\u2500" if is_last else "\u251c\u2500"
            atype = a["agent_type"]
            adur = fmt_dur(a["started_at"], a.get("stopped_at"))
            running = a in children
            color = MAGENTA if running else DIM
            safe_add(stdscr, pr, x + 2, f"{connector} {atype}  {adur}", rw, color)
            pr += 1
        pr += 1

    # Tool timeline (always show)
    tools = session_tools.get(target_sid, []) or tool_events.get(target_sid, [])
    if tools:
        safe_add(stdscr, pr, x + 2, f"TOOLS  {len(tools)}", rw, CYAN)
        pr += 1
        for t in tools:
            if pr >= y + h:
                break
            ts = fmt_time(t.get("created_at", ""))
            desc = friendly_tool(t["tool_name"], t.get("tool_label", ""))
            safe_add(stdscr, pr, x + 2, ts, rw, DIM)
            safe_add(stdscr, pr, x + 11, desc[:w - 14], rw, YELLOW)
            pr += 1
    elif pr < y + h:
        safe_add(stdscr, pr, x + 2, "(no tools)", rw, DIM)


def _draw_viz_graph_removed():
    """Removed — was flow graph. Kept as placeholder to avoid index issues."""
    pass


def _unused_graph():
    active_all = cache.get("active_all", [])
    rw_abs = x + w - 1

    # Pick session
    vis = state.get("visible_items", [])
    sel = state.get("selected", -1)
    sel_item = vis[sel] if 0 <= sel < len(vis) else None
    target_sid = sel_item.get("session_id", "") if sel_item else ""
    if not target_sid and active_all:
        target_sid = active_all[0]["session_id"]
    if not target_sid:
        safe_add(stdscr, y + 1, x + 2, "select a session", rw_abs, DIM)
        return

    # Query conversation turns (cached per session, refreshed with data)
    graph_cache = state.setdefault("_graph_cache", {})
    cache_key = f"{target_sid}:{frame // DATA_FRAMES}"  # refresh with data cycle
    if graph_cache.get("key") != cache_key:
        try:
            conn = sqlite3.connect(DB_PATH)
            conn.row_factory = sqlite3.Row
            prompts = conn.execute(
                "SELECT prompt, created_at, seq FROM prompt WHERE session_id = ? ORDER BY seq ASC LIMIT 10",
                (target_sid,)
            ).fetchall()
            agents = conn.execute(
                "SELECT agent_id, agent_type, started_at, stopped_at FROM agent WHERE session_id = ? ORDER BY started_at ASC",
                (target_sid,)
            ).fetchall()
            tools = conn.execute(
                "SELECT tool_name, tool_label, created_at FROM tool_event WHERE session_id = ? ORDER BY created_at ASC LIMIT 50",
                (target_sid,)
            ).fetchall()
            conn.close()
            graph_cache.update({"key": cache_key, "prompts": [dict(r) for r in prompts],
                                "agents": [dict(r) for r in agents], "tools": [dict(r) for r in tools]})
        except Exception:
            safe_add(stdscr, y + 1, x + 2, "(db error)", rw_abs, DIM)
            return
    prompts = graph_cache.get("prompts", [])
    agents = graph_cache.get("agents", [])
    tools = graph_cache.get("tools", [])

    if not prompts:
        safe_add(stdscr, y + 1, x + 2, f"session {target_sid[:7]}: no data", rw_abs, DIM)
        return

    # Build layers: assign agents and tools to their prompt turn by timestamp
    layers = []
    for pi, p in enumerate(prompts):
        turn_start = p["created_at"]
        turn_end = prompts[pi + 1]["created_at"] if pi + 1 < len(prompts) else "9999-12-31"
        turn_agents = []
        for a in agents:
            if turn_start <= a["started_at"] < turn_end:
                atype = a["agent_type"] or "agent"
                # Tools used by this agent (approximate: tools during agent lifetime)
                a_start = a["started_at"]
                a_end = a["stopped_at"] or "9999-12-31"
                a_tools = [friendly_tool(t["tool_name"], t["tool_label"])
                           for t in tools if a_start <= t["created_at"] <= a_end]
                turn_agents.append({"type": atype, "tools": a_tools[:3]})
        # Direct tools (not during any agent)
        direct_tools = []
        for t in tools:
            if turn_start <= t["created_at"] < turn_end:
                in_agent = any(a["started_at"] <= t["created_at"] <= (a["stopped_at"] or "9999-12-31") for a in agents)
                if not in_agent:
                    direct_tools.append(friendly_tool(t["tool_name"], t["tool_label"]))
        prompt_text = short_prompt(p["prompt"], w - 8) or f"turn {p['seq']}"
        layers.append({"prompt": prompt_text, "agents": turn_agents, "tools": direct_tools[:3]})

    # Build flat node list for hover navigation
    graph_nodes = []  # [{type, label, detail, row, col}]
    for li, layer in enumerate(layers):
        graph_nodes.append({"type": "prompt", "label": layer["prompt"],
                            "detail": f"Turn {li + 1}: {layer['prompt']}", "layer": li})
        for a in layer["agents"]:
            tools_str = ", ".join(a["tools"][:5]) if a["tools"] else "(no tools)"
            graph_nodes.append({"type": "agent", "label": a["type"],
                                "detail": f"{a['type']}: {tools_str}", "layer": li})
            for t in a["tools"]:
                graph_nodes.append({"type": "tool", "label": t,
                                    "detail": t, "layer": li})
        for t in layer["tools"]:
            graph_nodes.append({"type": "tool", "label": t, "detail": t, "layer": li})
    state["graph_nodes"] = graph_nodes

    # Hover index
    hover = state.get("graph_hover", 0)
    if graph_nodes:
        hover = max(0, min(hover, len(graph_nodes) - 1))
        state["graph_hover"] = hover

    # Render top-to-bottom flow
    pr = y
    mid = x + w // 2
    type_icons = {"prompt": "\u25c9", "agent": "\u25c8", "tool": "\u25cb"}
    node_idx = 0  # tracks position in graph_nodes

    for li, layer in enumerate(layers):
        if pr >= y + h - 1:
            break

        # Prompt node (centered)
        plabel = layer["prompt"][:w - 6]
        px = mid - len(plabel) // 2 - 1
        is_hov = (node_idx == hover)
        pcolor = (CYAN | curses.A_BOLD) if is_hov else GREEN
        safe_add(stdscr, pr, px, f"\u25c9 {plabel}", rw_abs, pcolor)
        if is_hov:
            safe_add(stdscr, pr, x + 2, "\u25b6", rw_abs, CYAN)
        prompt_row = pr
        pr += 1
        node_idx += 1

        # Fan-out: agents + direct tools spread horizontally
        children = []
        for a in layer["agents"]:
            children.append(("agent", a["type"], a["tools"]))
        for t in layer["tools"]:
            children.append(("tool", t, []))

        if children and pr < y + h - 1:
            n_kids = len(children)
            spacing = max(1, (w - 8) // max(n_kids, 1))
            start_x = x + 4

            for ci, (ctype, clabel, ctools) in enumerate(children):
                if pr >= y + h - 1:
                    break
                cx = start_x + ci * spacing
                icon = type_icons.get(ctype, "\u25cb")

                # Connection line from prompt
                if prompt_row + 1 == pr:
                    if cx < mid:
                        safe_add(stdscr, pr, cx, "\u2571", rw_abs, DIM)
                    elif cx > mid:
                        safe_add(stdscr, pr, cx, "\u2572", rw_abs, DIM)
                    else:
                        safe_add(stdscr, pr, cx, "\u2502", rw_abs, DIM)

                pr_child = pr + 1 if prompt_row + 1 == pr else pr
                if pr_child < y + h:
                    is_hov = (node_idx == hover)
                    color = (CYAN | curses.A_BOLD) if is_hov else (MAGENTA if ctype == "agent" else YELLOW)
                    safe_add(stdscr, pr_child, cx, f"{icon} {clabel[:spacing - 3]}", rw_abs, color)
                    if is_hov:
                        safe_add(stdscr, pr_child, x + 2, "\u25b6", rw_abs, CYAN)
                    node_idx += 1

                    # Tool leaves under agent
                    for ti, tl in enumerate(ctools):
                        if pr_child + 1 + ti >= y + h:
                            node_idx += 1
                            continue
                        conn = "\u2514" if ti == len(ctools) - 1 else "\u251c"
                        is_hov = (node_idx == hover)
                        tcolor = (CYAN | curses.A_BOLD) if is_hov else DIM
                        safe_add(stdscr, pr_child + 1 + ti, cx + 1, f"{conn} {tl[:spacing - 5]}", rw_abs, tcolor)
                        if is_hov:
                            safe_add(stdscr, pr_child + 1 + ti, x + 2, "\u25b6", rw_abs, CYAN)
                        node_idx += 1

            pr = pr_child + 1 + max((len(c[2]) for c in children), default=0)
        else:
            pr += 1

        # Convergence lines to next prompt
        if li < len(layers) - 1 and pr < y + h - 1:
            safe_add(stdscr, pr, mid, "\u2502", rw_abs, DIM)
            pr += 1

    # Legend + hover info
    if pr < y + h:
        safe_add(stdscr, y + h - 1, x + 2, "\u25c9 prompt", rw_abs, GREEN)
        safe_add(stdscr, y + h - 1, x + 13, "\u25c8 agent", rw_abs, MAGENTA)
        safe_add(stdscr, y + h - 1, x + 23, "\u25cb tool", rw_abs, YELLOW)


def _progress_bar(done, in_progress, total, width=5):
    """Build a compact progress bar: █ for done, ▓ for in_progress, ░ for remaining."""
    if total <= 0:
        return "░" * width
    filled = int(done / total * width)
    active = int(in_progress / total * width)
    # Ensure at least 1 char for in_progress if any exist
    if in_progress > 0 and active == 0 and filled < width:
        active = 1
    remaining = width - filled - active
    return "█" * filled + "▓" * active + "░" * max(0, remaining)


def member_status(activity_buckets, session):
    """Return (icon, color) based on member activity."""
    recent = activity_buckets[-5:] if activity_buckets else []
    has_recent_tools = any(b > 0 for b in recent)
    waiting = bool(session.get("lastWaitUserAt"))
    if has_recent_tools:
        return ("◉", GREEN)
    elif waiting:
        return ("○", DIM)
    else:
        return ("◎", YELLOW)


# ── BOX DRAWING ──────────────────────────────────────────────

def draw_box(stdscr, y, x, h, w, title="", title_attr=0, border_attr=0):
    if h < 2 or w < 2:
        return
    ba = border_attr or DIM
    ta = title_attr or CYAN
    top = SYMBOLS["tl"] + SYMBOLS["h"] * (w - 2) + SYMBOLS["tr"]
    if title:
        label = f" {title} "
        if len(label) + 2 < w:
            top = top[:2] + label + top[2 + len(label):]
    safe_add(stdscr, y, x, top, x + w, ba)
    if title:
        safe_add(stdscr, y, x + 2, f" {title} ", x + w, ta)
    for row in range(y + 1, y + h - 1):
        safe_add(stdscr, row, x, SYMBOLS["v"], x + w, ba)
        safe_add(stdscr, row, x + w - 1, SYMBOLS["v"], x + w, ba)
    bot = SYMBOLS["bl"] + SYMBOLS["h"] * (w - 2) + SYMBOLS["br"]
    safe_add(stdscr, y + h - 1, x, bot, x + w, ba)


# ── MAIN DRAW + LOOP ────────────────────────────────────────

def refresh_data(cache: dict, stats_range_idx: int = 2) -> dict:
    """Refresh cached dashboard data from DB + filesystem."""
    data = query_db(DB_PATH, stats_range_idx)
    data["_stats_range_idx"] = stats_range_idx
    active_all = data["active_sessions"]
    active_sids_all = {s["session_id"] for s in active_all}
    team_data = query_teams(DB_PATH, active_sids_all)
    cache.update({
        "data": data,
        "active_all": active_all,
        "r_agents": data["running_agents"],
        "c_agents": data["completed_agents"],
        "recent": data["recent_prompts"],
        "tool_events": data["tool_events"],
        "session_tools": data["session_tools"],
        "activity": data["activity"],
        "team_data": team_data,
        "session_lookup": {s["session_id"]: s for s in active_all},
    })
    return cache


def _detail_content_height(sel_agent, pw, cache):
    """Estimate how many content rows DETAIL needs (excluding box borders)."""
    if not sel_agent:
        return 3
    if sel_agent.get("is_session"):
        rows = 2  # header + divider
        prompt = (sel_agent.get("prompt", "") or "").replace("\n", " ").strip()
        if prompt:
            rows += 1  # prompt line
        sid = sel_agent.get("session_id", "")
        n_tools = len(cache.get("session_tools", {}).get(sid, []))
        if n_tools:
            rows += 1 + n_tools  # blank + tool lines
        return rows
    if sel_agent.get("is_teammate"):
        tasks = sel_agent.get("_tasks", [])
        return 2 + (1 if not tasks else 2 + len(tasks))  # header + divider + progress + blank + tasks
    if sel_agent.get("is_stat"):
        return 2 + 2 + 10  # header + divider + avg + recent runs/targets
    # Agent transcript — cap preview at 8
    return 2 + 8


def _draw_detail(stdscr, pr, col, max_row, max_col, sel_agent, cache, scroll=0):
    """Render DETAIL content into a region defined by (pr, col) to (max_row, max_col)."""
    pw = max_col - col  # available width
    base_pr = pr  # top of drawable area

    def P(r, c, text, attr=0):
        sr = r - scroll  # screen row after scroll
        if base_pr <= sr < max_row:
            safe_add(stdscr, sr, c, text, max_col, attr)

    # Adjust max_row for virtual space (allow pr to go beyond visible area)
    max_row_virtual = max_row + scroll

    if sel_agent and sel_agent.get("is_session"):
        # Rich session detail
        sid = sel_agent["session_id"]
        dur = fmt_dur(sel_agent.get("started_at", ""))
        sid_short = sid[:7]
        cwd = sel_agent.get("cwd", "")
        prompt_text = sel_agent.get("prompt", "")
        tag = dir_tag(cwd)
        header = f"{sid_short} \u00b7 {tag} session \u00b7 {dur}" if tag else f"{sid_short} \u00b7 session \u00b7 {dur}"
        P(pr, col, header[:pw], GREEN | curses.A_BOLD)
        pr += 1
        P(pr, col, SYMBOLS["h"] * pw, DIM)
        pr += 1

        # Prompt
        if prompt_text and pr < max_row_virtual:
            display_prompt = prompt_text.replace("\n", " ").strip()
            if display_prompt.startswith("<"):
                display_prompt = "(system prompt)"
            P(pr, col, display_prompt[:pw], WHITE)
            pr += 1

        # Tool event timeline
        session_tools = cache.get("session_tools", {}).get(sid, [])
        if session_tools and pr < max_row_virtual:
            pr += 1
            for ev in session_tools:
                if pr >= max_row_virtual:
                    break
                ts = fmt_time(ev.get("created_at"))
                tool_str = friendly_tool(ev["tool_name"], ev.get("tool_label", ""))
                P(pr, col, ts, DIM)
                P(pr, col + 9, tool_str[:pw - 10], YELLOW)
                pr += 1

    elif sel_agent and sel_agent.get("is_teammate"):
        # Task list for selected team member
        team_name = sel_agent.get("team_name", "")
        teammate_name = sel_agent.get("teammate_name", "")
        dur = fmt_dur(sel_agent.get("started_at", ""))
        sid_short = sel_agent["agent_id"][:7]
        header = f"{sid_short} \u00b7 {team_name}/{teammate_name} \u00b7 {dur}"
        P(pr, col, header[:pw], CYAN | curses.A_BOLD)
        pr += 1
        P(pr, col, SYMBOLS["h"] * pw, DIM)
        pr += 1
        tasks_list = sel_agent.get("_tasks", [])
        sorted_tasks = sorted(
            tasks_list,
            key=lambda t: {"in_progress": 0, "pending": 1, "completed": 2}.get(t.get("status", ""), 1),
        )
        if not sorted_tasks:
            P(pr, col, "(no tasks)", DIM)
        else:
            t_done = sum(1 for t in sorted_tasks if t.get("status") == "completed")
            t_active = sum(1 for t in sorted_tasks if t.get("status") == "in_progress")
            t_blocked = sum(1 for t in sorted_tasks if t.get("status") == "pending" and t.get("blockedBy"))
            t_total = len(sorted_tasks)
            pbar = _progress_bar(t_done, t_active, t_total, 10)
            pct = int(t_done / t_total * 100) if t_total else 0
            parts = [f"{t_done} done"]
            if t_active:
                parts.append(f"{t_active} active")
            if t_blocked:
                parts.append(f"{t_blocked} blocked")
            t_pending_unblocked = t_total - t_done - t_active - t_blocked
            if t_pending_unblocked > 0:
                parts.append(f"{t_pending_unblocked} pending")
            P(pr, col, f"{pbar} {pct}%  {' \u00b7 '.join(parts)}", CYAN)
            pr += 1
            pr += 1  # blank line

            for t in sorted_tasks:
                if pr >= max_row_virtual:
                    break
                status = t.get("status", "")
                blocked = bool(t.get("blockedBy")) and status == "pending"
                if status == "completed":
                    icon = "\u2713"
                elif status == "in_progress":
                    icon = "\u25cf"
                elif blocked:
                    icon = "\u2298"
                else:
                    icon = "\u25cb"
                owner = t.get("owner", "")
                owner_tag = f"  [@{owner}]" if owner else ""
                subject = short_prompt(t.get("subject", "?"), pw - 6 - len(owner_tag))
                if status == "completed":
                    attr = DIM
                elif status == "in_progress":
                    attr = YELLOW
                elif blocked:
                    attr = RED
                else:
                    attr = WHITE
                P(pr, col, f"{icon}  {subject}{owner_tag}", attr)
                pr += 1

    elif sel_agent:
        # Live preview of selected subagent
        dur = fmt_dur(sel_agent["started_at"])
        atype = sel_agent.get("agent_type") or "agent"
        aid = sel_agent["agent_id"][:7]
        tag = dir_tag(sel_agent.get("cwd", ""))
        header = f"{aid} \u00b7 {tag} {atype} \u00b7 {dur}" if tag else f"{aid} \u00b7 {atype} \u00b7 {dur}"
        P(pr, col, header[:pw], MAGENTA | curses.A_BOLD)
        pr += 1
        P(pr, col, SYMBOLS["h"] * pw, DIM)
        pr += 1
        for line in read_preview_lines(sel_agent, max_row_virtual - pr):
            if pr >= max_row_virtual:
                break
            P(pr, col, line[:pw], WHITE)
            pr += 1

    elif sel_agent and sel_agent.get("is_stat"):
        # Stats drill-down
        kind = sel_agent.get("stat_kind", "")
        label = sel_agent.get("stat_label", "?")
        cnt = sel_agent.get("stat_count", 0)
        cwd = sel_agent.get("cwd", "")
        atype = sel_agent.get("agent_type", "")
        tag = dir_tag(cwd)

        P(pr, col, f"{label}  ({cnt} total)", CYAN | curses.A_BOLD)
        pr += 1
        P(pr, col, SYMBOLS["h"] * pw, DIM)
        pr += 1

        # Query recent instances from DB (cached per selection)
        stat_cache = cache.setdefault("_stat_drill", {})
        stat_key = f"{kind}:{atype}:{cwd}"
        if stat_cache.get("key") != stat_key:
            stat_cache["key"] = stat_key
            stat_cache["data"] = None
            try:
                conn = sqlite3.connect(DB_PATH)
                conn.row_factory = sqlite3.Row
                range_idx = cache.get("data", {}).get("_stats_range_idx", 2)
                _, sql_interval = STATS_RANGES[min(range_idx, len(STATS_RANGES) - 1)]
                if kind == "agent":
                    time_filter = f"AND started_at > datetime('now', '{sql_interval}')" if sql_interval else ""
                    cwd_filter = f"AND cwd = '{cwd}'" if cwd else ""
                    stat_cache["data"] = {"rows": [dict(r) for r in conn.execute(
                        f"SELECT agent_id, agent_type, cwd, started_at, stopped_at FROM agent WHERE agent_type = ? {time_filter} {cwd_filter} ORDER BY started_at DESC LIMIT 8",
                        (atype,)).fetchall()]}
                elif kind == "tool":
                    time_filter = f"AND te.created_at > datetime('now', '{sql_interval}')" if sql_interval else ""
                    cwd_filter = f"AND p.cwd = '{cwd}'" if cwd else ""
                    stat_cache["data"] = {
                        "labels": [dict(r) for r in conn.execute(
                            f"SELECT te.tool_label, COUNT(*) as cnt FROM tool_event te LEFT JOIN prompt p ON te.session_id = p.session_id WHERE te.tool_name = ? {time_filter} {cwd_filter} GROUP BY te.tool_label ORDER BY cnt DESC LIMIT 8",
                            (atype,)).fetchall()],
                        "recent": [dict(r) for r in conn.execute(
                            f"SELECT te.tool_label, te.created_at, te.session_id FROM tool_event te LEFT JOIN prompt p ON te.session_id = p.session_id WHERE te.tool_name = ? {time_filter} {cwd_filter} ORDER BY te.created_at DESC LIMIT 6",
                            (atype,)).fetchall()],
                    }
                conn.close()
            except Exception:
                stat_cache["data"] = None
        sd = stat_cache.get("data")
        if sd and kind == "agent":
            rows = sd.get("rows", [])
            if rows:
                durs = []
                for r in rows:
                    if r.get("stopped_at") and r.get("started_at"):
                        try:
                            s = datetime.fromisoformat(r["started_at"]).replace(tzinfo=timezone.utc)
                            e = datetime.fromisoformat(r["stopped_at"]).replace(tzinfo=timezone.utc)
                            durs.append((e - s).total_seconds())
                        except Exception:
                            pass
                if durs:
                    avg = int(sum(durs) / len(durs))
                    P(pr, col, f"avg duration: {avg}s", DIM)
                    pr += 1
                pr += 1
                P(pr, col, "RECENT RUNS", CYAN)
                pr += 1
                for r in rows:
                    if pr >= max_row_virtual:
                        break
                    aid = short_id(r["agent_id"])
                    dur = fmt_dur(r["started_at"], r.get("stopped_at")) if r.get("stopped_at") else fmt_dur(r["started_at"])
                    ts = fmt_time(r["started_at"])
                    running = "\u25cf" if not r.get("stopped_at") else "\u25cb"
                    P(pr, col, f"{running} {ts}  {dur:>6}  {aid}", DIM)
                    pr += 1
            else:
                P(pr, col, "(no recent runs)", DIM)
        elif sd and kind == "tool":
            label_rows = sd.get("labels", [])
            if label_rows:
                P(pr, col, "TOP TARGETS", CYAN)
                pr += 1
                max_lc = label_rows[0]["cnt"] if label_rows else 1
                for lr in label_rows:
                    if pr >= max_row_virtual:
                        break
                    tl = lr["tool_label"] or "(none)"
                    tc = lr["cnt"]
                    bw = 6
                    filled = int(tc / max_lc * bw) if max_lc > 0 else 0
                    bar = "\u2588" * filled + "\u2591" * (bw - filled)
                    P(pr, col, f"{bar} {tc:>3}  {tl[:pw - 14]}", DIM)
                    pr += 1
                pr += 1
                recent_rows = sd.get("recent", [])
                if recent_rows and pr < max_row_virtual:
                    P(pr, col, "RECENT", CYAN)
                    pr += 1
                    for rr in recent_rows:
                        if pr >= max_row_virtual:
                            break
                        ts = fmt_time(rr["created_at"])
                        tl = rr["tool_label"] or ""
                        sid = short_session(rr["session_id"])
                        P(pr, col, f"{ts}  {sid}  {tl[:pw - 18]}", DIM)
                        pr += 1
            else:
                P(pr, col, "(no recent uses)", DIM)
        else:
            P(pr, col, "(no data)", DIM)

    else:
        # Nothing selected — show keybinding hints
        P(pr, col, "j/k  select", DIM)
        pr += 1
        P(pr, col, "esc  deselect", DIM)
        pr += 1
        P(pr, col, "ret  open in iTerm2", DIM)


def draw(stdscr, frame: int, state: dict, cache: dict):
    stdscr.erase()
    h, w = stdscr.getmaxyx()
    if h < 5 or w < 30:
        safe_add(stdscr, 0, 0, "terminal too small", w, 0)
        stdscr.refresh()
        return

    spins = "\u280b\u2819\u2839\u2838\u283c\u2834\u2826\u2827\u2807\u280f"
    sc = spins[frame % len(spins)]
    pulse = ("○", "◎", "●", "◎")[frame % 4]

    active_all = cache["active_all"]
    r_agents = cache["r_agents"]
    c_agents = cache["c_agents"]
    recent = cache["recent"]
    tool_events = cache["tool_events"]
    activity = cache["activity"]
    team_data = cache["team_data"]
    session_lookup = cache["session_lookup"]

    team_session_ids = team_data["team_session_ids"]
    teams = team_data["teams"]

    # Solo sessions: exclude team members (shown in TEAMS section instead)
    active = [s for s in active_all if s["session_id"] not in team_session_ids]

    # Build agents_by_session, track orphans
    active_sids = {s["session_id"] for s in active}
    agents_by_session: dict[str, list[dict]] = {}
    orphan_agents: list[dict] = []
    for a in r_agents:
        if a["session_id"] in active_sids:
            agents_by_session.setdefault(a["session_id"], []).append(a)
        else:
            orphan_agents.append(a)

    # Layout
    split = w >= 100
    lw = w // 2 if split else w
    rw = w - lw if split else 0
    rx = lw  # right panel x position

    top_agents = cache["data"].get("top_agents", [])
    top_tools = cache["data"].get("top_tools", [])

    # Helpers: clip to panel widths (preserve box borders)
    def L(r, c, text, attr=0):
        safe_add(stdscr, r, c, text, lw - 1, attr)

    def R(r, c, text, attr=0):
        safe_add(stdscr, r, c, text, rx + rw - 1, attr)

    # Reset visible items for keyboard nav
    visible_items: list[dict] = []
    # Track panel index ranges for border highlighting: [(y, h, first_idx, last_idx, title)]
    panel_ranges: list[tuple] = []

    n_team_members = sum(len(t["members"]) for t in teams)
    total_live = len(active) + len(r_agents) + n_team_members

    # -- Title bar (row 0-1, full width) --
    row = 0
    now = datetime.now(timezone.utc).strftime("%H:%M:%S")
    if total_live > 0:
        title = f" {sc} CLAUDE AGENTS"
        counts = []
        if teams:
            tm_count = n_team_members
            counts.append(f"{len(teams)} team{'s' if len(teams) != 1 else ''} \u00b7 {tm_count} active")
        if active:
            counts.append(f"{len(active)} session{'s' if len(active) != 1 else ''}")
        if r_agents:
            counts.append(f"{len(r_agents)} agent{'s' if len(r_agents) != 1 else ''}")
        count_str = f"  {' \u00b7 '.join(counts)}"
        title_attr = WHITE
    else:
        title = "   CLAUDE AGENTS"
        count_str = "  idle"
        title_attr = GREEN

    safe_add(stdscr, row, 0, title, w, title_attr)
    safe_add(stdscr, row, len(title), count_str, w, DIM)
    safe_add(stdscr, row, w - len(now) - 1, now, w, DIM)
    row += 1
    safe_add(stdscr, row, 0, SYMBOLS["h"] * w, w, DIM)
    row += 1
    content_top = row

    # -- Compute panel heights --
    # Teams panel
    n_team_subheaders = len(teams) if len(teams) > 1 else 0
    n_active_task_rows = 0
    for team in teams:
        for m in team["members"]:
            if any(t.get("owner") == m.get("teammate_name") and t.get("status") == "in_progress"
                   for t in team["tasks"]):
                n_active_task_rows += 1
    teams_h = (2 + n_team_members + n_active_task_rows + n_team_subheaders) if teams else 0

    # Sessions panel: each session gets 1 row + 1 inline tool row if it has recent tools
    n_sess_rows = 0
    for s in active:
        n_sess_rows += 1
        if s["session_id"] in tool_events:
            n_sess_rows += 1  # inline tool line
    n_sess_rows += len(orphan_agents)
    sess_h = (2 + n_sess_rows) if (active or orphan_agents) else 0

    # History + Stats share remaining left-panel space
    max_hist = 8
    remaining = max(6, h - content_top - teams_h - sess_h - 1)
    hist_h = min(2 + max_hist, remaining // 2 + remaining % 2)
    stats_lh = remaining - hist_h  # left-side stats height

    # If nothing active, show a small sessions box with idle message
    if not teams and not active and not r_agents:
        sess_h = 3
        remaining = max(6, h - content_top - sess_h - 1)
        hist_h = min(2 + max_hist, remaining // 2 + remaining % 2)
        stats_lh = remaining - hist_h

    # -- TEAMS panel --
    cr = content_top
    if teams:
        # Build title
        if len(teams) == 1:
            t0 = teams[0]
            tl = t0["tasks"]
            tdone = sum(1 for x in tl if x.get("status") == "completed")
            trinp = sum(1 for x in tl if x.get("status") == "in_progress")
            ttotal = len(tl)
            if ttotal > 0:
                bar = _progress_bar(tdone, trinp, ttotal, 5)
                tcounts = f"  {bar} {tdone}/{ttotal}"
            else:
                tcounts = ""
            box_title = f"TEAMS  {t0['name']}{tcounts}"
        else:
            box_title = f"TEAMS  {len(teams)} teams \u00b7 {n_team_members} active"

        teams_first_idx = len(visible_items)
        draw_box(stdscr, cr, 0, teams_h, lw, title=box_title)
        tr = cr + 1  # first content row inside box

        for team in teams:
            if tr >= cr + teams_h - 1:
                break
            if len(teams) > 1:
                # Sub-header per team
                tl = team["tasks"]
                tdone = sum(1 for x in tl if x.get("status") == "completed")
                trinp = sum(1 for x in tl if x.get("status") == "in_progress")
                ttotal = len(tl)
                if ttotal > 0:
                    bar = _progress_bar(tdone, trinp, ttotal, 5)
                    tcounts = f"  {bar} {tdone}/{ttotal}"
                else:
                    tcounts = ""
                L(tr, 2, f"\u25c8 {team['name']}{tcounts}", CYAN)
                tr += 1
                base = 4
            else:
                base = 2

            members = team["members"]
            for i, m in enumerate(members):
                if tr >= cr + teams_h - 1:
                    break
                is_last = (i == len(members) - 1)
                connector = "\u2514\u2500" if is_last else "\u251c\u2500"
                sess = session_lookup.get(m["session_id"], {})
                started_at = sess.get("created_at", "")
                dur = fmt_dur(started_at) if started_at else "?"
                teammate_name = m.get("teammate_name") or "teammate"
                sid_short = short_session(m["session_id"])
                item = {
                    "agent_id": m["session_id"],
                    "agent_type": teammate_name,
                    "session_id": m["session_id"],
                    "started_at": started_at,
                    "cwd": sess.get("cwd", ""),
                    "team_name": team["name"],
                    "teammate_name": teammate_name,
                    "is_teammate": True,
                    "_tasks": team["tasks"],
                }
                vidx = len(visible_items)
                visible_items.append(item)
                is_sel = (vidx == state.get("selected", -1))

                # Sparkline + status for this teammate
                spark = sparkline(activity.get(m["session_id"], []))
                s_icon, s_color = member_status(activity.get(m["session_id"], []), sess)

                if is_sel:
                    try:
                        stdscr.addnstr(tr, 1, " " * (lw - 2), lw - 2, SEL_DIM)
                    except curses.error:
                        pass
                    L(tr, base, connector, SEL_DIM)
                    L(tr, base + 3, "\u25b6", SEL_YELLOW)
                    L(tr, base + 5, f"{dur:>5}", SEL_YELLOW)
                    L(tr, base + 11, sid_short, SEL_DIM)
                    L(tr, base + 18, teammate_name, SEL)
                    L(tr, lw - 12, spark, SEL_DIM)
                else:
                    L(tr, base, connector, DIM)
                    L(tr, base + 3, s_icon, s_color)
                    L(tr, base + 5, f"{dur:>5}", YELLOW)
                    L(tr, base + 11, sid_short, DIM)
                    L(tr, base + 18, teammate_name, WHITE)
                    L(tr, lw - 12, spark, CYAN)
                tr += 1

                # Active task row under this member
                active_task = None
                for t in team["tasks"]:
                    if t.get("owner") == teammate_name and t.get("status") == "in_progress":
                        active_task = t
                        break
                if active_task and tr < cr + teams_h - 1:
                    continuation = "\u2502" if not is_last else " "
                    task_text = active_task.get("activeForm") or active_task.get("subject", "")
                    task_text = task_text[:lw - base - 10]
                    if is_sel:
                        try:
                            stdscr.addnstr(tr, 1, " " * (lw - 2), lw - 2, SEL_DIM)
                        except curses.error:
                            pass
                        L(tr, base, continuation, SEL_DIM)
                        L(tr, base + 5, "\u25cf", SEL_YELLOW)
                        L(tr, base + 7, task_text, SEL_YELLOW)
                    else:
                        L(tr, base, continuation, DIM)
                        L(tr, base + 5, "\u25cf", YELLOW)
                        L(tr, base + 7, task_text, YELLOW)
                    tr += 1

        panel_ranges.append((content_top, teams_h, teams_first_idx, len(visible_items) - 1, box_title))
        cr += teams_h

    # -- SESSIONS panel --
    if active or orphan_agents:
        n_running = sum(
            1 for s in active
            if not s.get("lastWaitUserAt") or s["session_id"] in agents_by_session
        )
        n_waiting = len(active) - n_running
        sess_counts = []
        if n_running:
            sess_counts.append(f"{n_running} running")
        if n_waiting:
            sess_counts.append(f"{n_waiting} waiting")
        if r_agents:
            sess_counts.append(f"{len(r_agents)} agent{'s' if len(r_agents) != 1 else ''}")
        sess_title = f"SESSIONS  {' \u00b7 '.join(sess_counts)}" if sess_counts else "SESSIONS"

        sess_first_idx = len(visible_items)
        draw_box(stdscr, cr, 0, sess_h, lw, title=sess_title)
        sr = cr + 1

        for s in active:
            if sr >= cr + sess_h - 1:
                break
            sid = s["session_id"]
            has_agents = sid in agents_by_session
            waiting = bool(s.get("lastWaitUserAt")) and not has_agents
            sid_short = short_session(sid)
            prompt = short_prompt(s.get("prompt"), max(10, lw - 32))
            spark = sparkline(activity.get(sid, []))

            # Make session selectable
            sess_item = {
                "agent_id": sid,
                "agent_type": "session",
                "session_id": sid,
                "started_at": s["created_at"],
                "cwd": s.get("cwd", ""),
                "is_session": True,
                "prompt": s.get("prompt", ""),
            }
            vidx = len(visible_items)
            visible_items.append(sess_item)
            is_sel = (vidx == state.get("selected", -1))

            if is_sel:
                try:
                    stdscr.addnstr(sr, 1, " " * (lw - 2), lw - 2, SEL_DIM)
                except curses.error:
                    pass
                L(sr, 2, "\u25b6", SEL_YELLOW)
                run_dur = fmt_dur(s["created_at"])
                L(sr, 4, f"{run_dur:>6}", SEL_YELLOW)
                L(sr, 11, sid_short, SEL_DIM)
                L(sr, 18, prompt, SEL)
                L(sr, lw - 12, spark, SEL_DIM)
            elif waiting:
                # Frozen clock: duration from start to when it stopped working
                frozen_dur = fmt_dur(s["created_at"], s.get("lastWaitUserAt"))
                L(sr, 2, "\u25a1", DIM)  # □ paused
                L(sr, 4, f"{frozen_dur:>6}", DIM)
                L(sr, 11, sid_short, DIM)
                L(sr, 18, prompt, DIM)
            else:
                run_dur = fmt_dur(s["created_at"])
                L(sr, 2, pulse, GREEN)
                L(sr, 4, f"{run_dur:>6}", YELLOW)
                L(sr, 11, sid_short, DIM)
                L(sr, 18, prompt, WHITE)
                L(sr, lw - 12, spark, CYAN)
            sr += 1

            # Inline tool line (most recent tool call for this session)
            if sid in tool_events and sr < cr + sess_h - 1:
                tools = tool_events[sid]
                parts = [friendly_tool(t["tool_name"], t.get("tool_label", "")) for t in tools]
                tool_line = "  ".join(parts)[:lw - 8]
                if is_sel:
                    try:
                        stdscr.addnstr(sr, 1, " " * (lw - 2), lw - 2, SEL_DIM)
                    except curses.error:
                        pass
                    L(sr, 4, "\u23bf", SEL_DIM)
                    L(sr, 6, tool_line, SEL_DIM)
                else:
                    L(sr, 4, "\u23bf", DIM)
                    L(sr, 6, tool_line, DIM)
                sr += 1

        # Orphan agents
        for a in orphan_agents:
            if sr >= cr + sess_h - 1:
                break
            dur = fmt_dur(a["started_at"])
            atype = a["agent_type"] or "agent"
            tag = dir_tag(a.get("cwd", ""))
            vidx = len(visible_items)
            visible_items.append(a)
            is_sel = (vidx == state.get("selected", -1))
            a_spark = sparkline(activity.get(a.get("session_id", ""), []))

            if is_sel:
                try:
                    stdscr.addnstr(sr, 1, " " * (lw - 2), lw - 2, SEL_DIM)
                except curses.error:
                    pass
                L(sr, 2, "\u25b6", SEL_YELLOW)
                L(sr, 4, f"{dur:>6}", SEL_YELLOW)
                col = 11
                if tag:
                    L(sr, col, tag, SEL_CYAN)
                    col += len(tag) + 1
                L(sr, col, atype, SEL)
                L(sr, col + len(atype) + 1, short_id(a["agent_id"]), SEL_DIM)
                L(sr, lw - 12, a_spark, SEL_DIM)
            else:
                L(sr, 2, sc, MAGENTA)
                L(sr, 4, f"{dur:>6}", YELLOW)
                col = 11
                if tag:
                    L(sr, col, tag, CYAN)
                    col += len(tag) + 1
                L(sr, col, atype, MAGENTA)
                L(sr, col + len(atype) + 1, short_id(a["agent_id"]), DIM)
                L(sr, lw - 12, a_spark, CYAN)
            sr += 1

        panel_ranges.append((cr, sess_h, sess_first_idx, len(visible_items) - 1, sess_title))
        cr += sess_h

    elif not teams:
        # No active sessions or agents — show idle box
        draw_box(stdscr, cr, 0, sess_h, lw, title="SESSIONS")
        L(cr + 1, 2, "no active sessions or agents", DIM)
        cr += sess_h

    # -- HISTORY or DETAIL-inline panel --
    # When something is selected and terminal is too narrow for side-by-side,
    # show DETAIL in the HISTORY panel's space instead.
    sel_idx = state.get("selected", -1)
    sel_agent = visible_items[sel_idx] if 0 <= sel_idx < len(visible_items) else None
    show_inline_detail = sel_agent is not None and not split

    hist_first_idx = len(visible_items)
    if show_inline_detail:
        draw_box(stdscr, cr, 0, hist_h, lw, title="DETAIL")
        _draw_detail(stdscr, cr + 1, 2, cr + hist_h - 1, lw - 1,
                     sel_agent, cache)
    else:
        draw_box(stdscr, cr, 0, hist_h, lw, title="HISTORY")
        hr = cr + 1

        history = []
        for a in c_agents:
            history.append(("agent", a["stopped_at"], a))
        for s in recent:
            history.append(("prompt", s["stoped_at"], s))
        history.sort(key=lambda x: x[1] or "", reverse=True)

        if not history:
            L(hr, 2, "(empty)", DIM)
        else:
            shown = 0
            for kind, ts, item in history:
                if hr >= cr + hist_h - 1 or shown >= max_hist:
                    break
                t = fmt_time(ts)
                if kind == "agent":
                    dur = fmt_dur(item["started_at"], item["stopped_at"])
                    atype = item.get("agent_type") or "agent"
                    hist_item = {
                        "agent_id": item.get("agent_id", ""),
                        "agent_type": atype,
                        "session_id": item.get("session_id", ""),
                        "started_at": item.get("started_at", ""),
                        "cwd": item.get("cwd", ""),
                        "is_history": True,
                        "kind": "agent",
                        "stopped_at": item.get("stopped_at", ""),
                        "transcript_path": item.get("transcript_path", ""),
                    }
                elif kind == "prompt":
                    dur = fmt_dur(item["created_at"], item["stoped_at"])
                    prompt = short_prompt(item.get("prompt"), max(10, lw - 21))
                    if not prompt:
                        continue
                    hist_item = {
                        "agent_id": item.get("session_id", ""),
                        "agent_type": "session",
                        "session_id": item.get("session_id", ""),
                        "started_at": item.get("created_at", ""),
                        "cwd": item.get("cwd", ""),
                        "is_history": True,
                        "is_session": True,
                        "kind": "prompt",
                        "prompt": item.get("prompt", ""),
                    }
                else:
                    continue

                vidx = len(visible_items)
                visible_items.append(hist_item)
                is_sel = (vidx == state.get("selected", -1))

                if kind == "agent":
                    if is_sel:
                        try:
                            stdscr.addnstr(hr, 1, " " * (lw - 2), lw - 2, SEL_DIM)
                        except curses.error:
                            pass
                        L(hr, 2, t, SEL_DIM)
                        L(hr, 11, f"{dur:>6}", SEL_DIM)
                        L(hr, 18, f"\u25b8 {atype}", SEL_MAGENTA)
                    else:
                        L(hr, 2, t, DIM)
                        L(hr, 11, f"{dur:>6}", DIM)
                        L(hr, 18, f"\u25b8 {atype}", curses.color_pair(6))
                else:
                    if is_sel:
                        try:
                            stdscr.addnstr(hr, 1, " " * (lw - 2), lw - 2, SEL_DIM)
                        except curses.error:
                            pass
                        L(hr, 2, t, SEL_DIM)
                        L(hr, 11, f"{dur:>6}", SEL_DIM)
                        L(hr, 18, prompt, SEL)
                    else:
                        L(hr, 2, t, DIM)
                        L(hr, 11, f"{dur:>6}", DIM)
                        L(hr, 18, prompt, DIM)
                hr += 1
                shown += 1

    if len(visible_items) > hist_first_idx:
        panel_ranges.append((cr, hist_h, hist_first_idx, len(visible_items) - 1, "HISTORY"))

    # -- STATS panel (bottom-left, below history) --
    cr_stats = cr + hist_h
    if stats_lh >= 4:
        range_label, _ = STATS_RANGES[state.get("stats_range", 2)]
        range_tabs = "  ".join(
            f"[{r[0]}]" if i == state.get("stats_range", 2) else r[0]
            for i, r in enumerate(STATS_RANGES)
        )
        stats_first_idx = len(visible_items)
        stats_hl_active = state.get("focus") == "left" and state.get("selected", -1) < 0
        draw_box(stdscr, cr_stats, 0, stats_lh, lw, title=f"STATS  {range_tabs}",
                 border_attr=CYAN if stats_hl_active else 0)
        sr = cr_stats + 1
        max_sr = cr_stats + stats_lh - 1

        def _bar(val: int, max_val: int, bw: int = 8) -> str:
            filled = int(val / max_val * bw) if max_val > 0 else 0
            return "\u2588" * filled + "\u2591" * (bw - filled)

        # Team metrics
        if teams and sr < max_sr - 2:
            for team in teams:
                if sr >= max_sr - 1:
                    break
                tl = team["tasks"]
                t_done = sum(1 for t in tl if t.get("status") == "completed")
                t_active = sum(1 for t in tl if t.get("status") == "in_progress")
                t_pending = sum(1 for t in tl if t.get("status") == "pending")
                t_total = len(tl)
                L(sr, 2, f"TEAMS  {team['name']}", CYAN)
                sr += 1
                if t_total > 0:
                    bar = _progress_bar(t_done, t_active, t_total, 10)
                    summary = f"{bar} {t_total} task{'s' if t_total != 1 else ''}  {t_done} done  {t_active} active  {t_pending} pending"
                    L(sr, 2, summary, DIM)
                    sr += 1
                sr += 1

        # Agent rankings
        if top_agents and sr < max_sr - 1:
            L(sr, 2, f"AGENTS  {range_label}", CYAN)
            sr += 1
            max_a = top_agents[0]["cnt"]
            tag_w = max((len(dir_tag(e.get("cwd", ""))) for e in top_agents), default=0)
            type_w = max((len(e["agent_type"] or "?") for e in top_agents), default=0)
            for entry in top_agents:
                if sr >= max_sr:
                    break
                tag = dir_tag(entry.get("cwd", ""))
                atype = entry["agent_type"] or "?"
                cnt = entry["cnt"]
                bar = _bar(cnt, max_a)
                col1 = tag.ljust(tag_w)
                col2 = atype.ljust(type_w)
                stat_item = {"agent_id": atype, "agent_type": atype, "session_id": "",
                             "started_at": "", "cwd": entry.get("cwd", ""), "is_stat": True,
                             "stat_kind": "agent", "stat_count": cnt, "stat_label": f"{tag} {atype}"}
                vidx = len(visible_items)
                visible_items.append(stat_item)
                is_sel = (vidx == state.get("selected", -1))
                if is_sel:
                    try:
                        stdscr.addnstr(sr, 1, " " * (lw - 2), lw - 2, SEL_DIM)
                    except curses.error:
                        pass
                    L(sr, 2, f"{col1}  {col2}  {bar} {cnt}", SEL)
                else:
                    L(sr, 2, f"{col1}  {col2}  {bar} {cnt}", DIM)
                sr += 1
            sr += 1

        # Tool rankings
        if top_tools and sr < max_sr - 1:
            L(sr, 2, f"TOOLS   {range_label}", CYAN)
            sr += 1
            max_t = top_tools[0]["cnt"]
            ttag_w = max((len(dir_tag(e.get("cwd", ""))) for e in top_tools), default=0)
            tname_w = max((len(e["tool_name"] or "?") for e in top_tools), default=0)
            for entry in top_tools:
                if sr >= max_sr:
                    break
                tag = dir_tag(entry.get("cwd", ""))
                tname = entry["tool_name"] or "?"
                cnt = entry["cnt"]
                bar = _bar(cnt, max_t)
                col1 = tag.ljust(ttag_w)
                col2 = tname.ljust(tname_w)
                stat_item = {"agent_id": tname, "agent_type": tname, "session_id": "",
                             "started_at": "", "cwd": entry.get("cwd", ""), "is_stat": True,
                             "stat_kind": "tool", "stat_count": cnt, "stat_label": f"{tag} {tname}"}
                vidx = len(visible_items)
                visible_items.append(stat_item)
                is_sel = (vidx == state.get("selected", -1))
                if is_sel:
                    try:
                        stdscr.addnstr(sr, 1, " " * (lw - 2), lw - 2, SEL_DIM)
                    except curses.error:
                        pass
                    L(sr, 2, f"{col1}  {col2}  {bar} {cnt}", SEL)
                else:
                    L(sr, 2, f"{col1}  {col2}  {bar} {cnt}", DIM)
                sr += 1

        if len(visible_items) > stats_first_idx:
            stats_title = f"STATS  {range_tabs}"
            panel_ranges.append((cr_stats, stats_lh, stats_first_idx, len(visible_items) - 1, stats_title))

    # Clamp selection to visible items and recompute sel_agent
    state["visible_items"] = visible_items
    if visible_items:
        state["selected"] = max(-1, min(state.get("selected", -1), len(visible_items) - 1))
    else:
        state["selected"] = -1
    sel_idx = state.get("selected", -1)
    sel_agent = visible_items[sel_idx] if 0 <= sel_idx < len(visible_items) else None

    # Highlight the left panel that contains the selected item
    if state.get("focus") == "left" and sel_idx >= 0:
        for py, ph, fi, li, ptitle in panel_ranges:
            if fi <= sel_idx <= li:
                draw_box(stdscr, py, 0, ph, lw, title=ptitle, border_attr=CYAN)
                break

    # -- Right panel (single panel: TREE or TIMELINE, toggled by Tab) --
    if split and rw > 10:
        total_rh = h - content_top - 1
        focused = state.get("focus") == "right"
        viz_mode = VIZ_MODES[state.get("viz_mode", 0) % len(VIZ_MODES)] if state.get("viz_mode", 0) < len(VIZ_MODES) else "life"

        # Build title with tab selector
        tabs = "  ".join(f"[{VIZ_LABELS[m]}]" if m == viz_mode else VIZ_LABELS[m] for m in VIZ_MODES)
        if state.get("game_of_life"):
            tabs += "  LIFE"
        title_prefix = "\u25b6 " if focused else ""
        draw_box(stdscr, content_top, rx, total_rh, rw,
                 title=f"{title_prefix}{tabs}",
                 border_attr=CYAN if focused else 0)

        panel_y = content_top + 1
        panel_h = total_rh - 2

        if viz_mode == "tree":
            # Merged: show DETAIL header + tree for selected item
            if sel_agent:
                pr = panel_y
                rw_abs = rx + rw - 1
                # Header
                sid_short = sel_agent["agent_id"][:7]
                dur = fmt_dur(sel_agent.get("started_at", ""))
                tag = dir_tag(sel_agent.get("cwd", ""))
                if sel_agent.get("is_session"):
                    header = f"{sid_short} \u00b7 {tag} \u00b7 {dur}" if tag else f"{sid_short} \u00b7 {dur}"
                    safe_add(stdscr, pr, rx + 2, header[:rw - 4], rw_abs, GREEN | curses.A_BOLD)
                elif sel_agent.get("is_teammate"):
                    tname = sel_agent.get("teammate_name", "")
                    header = f"{sid_short} \u00b7 {tname} \u00b7 {dur}"
                    safe_add(stdscr, pr, rx + 2, header[:rw - 4], rw_abs, CYAN | curses.A_BOLD)
                elif sel_agent.get("is_stat"):
                    safe_add(stdscr, pr, rx + 2, sel_agent.get("stat_label", "")[:rw - 4], rw_abs, CYAN | curses.A_BOLD)
                else:
                    atype = sel_agent.get("agent_type") or "agent"
                    header = f"{sid_short} \u00b7 {tag} {atype} \u00b7 {dur}" if tag else f"{sid_short} \u00b7 {atype} \u00b7 {dur}"
                    safe_add(stdscr, pr, rx + 2, header[:rw - 4], rw_abs, MAGENTA | curses.A_BOLD)
                pr += 1
                safe_add(stdscr, pr, rx + 2, SYMBOLS["h"] * (rw - 4), rw_abs, DIM)
                pr += 1
                # Tree below header
                _draw_viz_tree(stdscr, pr, rx, panel_y + panel_h - pr, rw, cache, state)
            else:
                _draw_viz_tree(stdscr, panel_y, rx, panel_h, rw, cache, state)

        elif viz_mode == "gantt":
            _draw_viz_gantt(stdscr, panel_y, rx, panel_h, rw, cache, state)

        elif state.get("game_of_life") and state.get("viz_mode", 0) >= len(VIZ_MODES):
            # Game of Life
            life_sid = None
            if sel_agent and sel_agent.get("is_session"):
                life_sid = sel_agent["session_id"]
            if not life_sid and active_all:
                life_sid = active_all[0]["session_id"]
            if not life_sid:
                life_sid = "idle"
            char_w = rw - 4
            char_h = panel_h
            grid_rows = char_h * 4
            grid_cols = char_w * 2
            life_grids = state.setdefault("life_grids", {})
            if life_sid not in life_grids:
                sess_info = session_lookup.get(life_sid, {})
                seed_str = (sess_info.get("prompt", "") or "") + life_sid
                random.seed(hash(seed_str))
                life_grids[life_sid] = {"grid": life_init(grid_rows, grid_cols, 0.25),
                                        "size": (grid_rows, grid_cols), "gen": 0}
                random.seed()
            elif life_grids[life_sid]["size"] != (grid_rows, grid_cols):
                old_grid = life_grids[life_sid]["grid"]
                old_r, old_c = life_grids[life_sid]["size"]
                new_grid = [[False] * grid_cols for _ in range(grid_rows)]
                for r in range(min(old_r, grid_rows)):
                    for c in range(min(old_c, grid_cols)):
                        new_grid[r][c] = old_grid[r][c]
                life_grids[life_sid]["grid"] = new_grid
                life_grids[life_sid]["size"] = (grid_rows, grid_cols)
            lg = life_grids[life_sid]
            for _ in range(5):
                lg["grid"] = life_step(lg["grid"], grid_rows, grid_cols)
                lg["gen"] += 1
            alive = sum(sum(row) for row in lg["grid"])
            if alive < 5:
                sess_info = session_lookup.get(life_sid, {})
                seed_str = (sess_info.get("prompt", "") or "") + life_sid + str(lg["gen"])
                random.seed(hash(seed_str))
                lg["grid"] = life_init(grid_rows, grid_cols, 0.25)
                random.seed()
            _life_colors = [DIM, DIM, CYAN, CYAN, GREEN, GREEN, YELLOW, YELLOW, YELLOW]
            lines = life_render(lg["grid"], grid_rows, grid_cols, char_w, char_h)
            lr = panel_y
            for row in lines:
                if lr >= panel_y + panel_h:
                    break
                cx = rx + 2
                for bch, density in row:
                    if cx >= rx + rw - 1:
                        break
                    safe_add(stdscr, lr, cx, bch, rx + rw - 1, _life_colors[min(density, 8)])
                    cx += 1
                lr += 1

    # -- Footer (full width) --
    status = state.get("status_msg", "")
    if status and time.time() < state.get("status_until", 0):
        safe_add(stdscr, h - 1, 0, f" {status}", w, YELLOW)
    elif visible_items:
        if state.get("focus") == "right":
            safe_add(stdscr, h - 1, 0, " j/k=scroll  h=back  tab=viz  enter=open  q=quit", w, DIM)
        elif state.get("selected", -1) >= 0:
            safe_add(stdscr, h - 1, 0, " j/k=select  l/enter=detail  h/l=stats  tab=viz  esc=deselect  q=quit", w, DIM)
        else:
            safe_add(stdscr, h - 1, 0, " j/k=select  h/l=stats range  tab=viz  q=quit", w, DIM)
    else:
        safe_add(stdscr, h - 1, 0, " tab=viz  q=quit", w, DIM)
    stdscr.refresh()


RENDER_MS = 200     # redraw interval (5 FPS — smooth enough, less CPU)
DATA_FRAMES = 10    # refresh DB every N frames (~2s at 200ms)


def main(stdscr, game_of_life=False):
    curses.curs_set(0)
    stdscr.nodelay(True)
    stdscr.timeout(RENDER_MS)
    stdscr.keypad(True)

    init_colors()

    state: dict = {"selected": -1, "visible_items": [], "status_msg": "", "status_until": 0.0,
                   "stats_range": 2, "game_of_life": game_of_life, "focus": "left", "detail_scroll": 0,
                   "viz_mode": 0}
    cache: dict = {}
    refresh_data(cache, state["stats_range"])
    frame = 0
    while True:
        if frame % DATA_FRAMES == 0:
            refresh_data(cache, state["stats_range"])
        draw(stdscr, frame, state, cache)
        frame += 1
        ch = stdscr.getch()
        if ch in (ord("q"), ord("Q")):
            break
        elif ch == 9:  # Tab — cycle viz mode forward
            n_modes = len(VIZ_MODES) + (1 if state.get("game_of_life") else 0)
            state["viz_mode"] = (state["viz_mode"] + 1) % n_modes
        elif ch == 353:  # Shift-Tab — cycle viz mode backward
            n_modes = len(VIZ_MODES) + (1 if state.get("game_of_life") else 0)
            state["viz_mode"] = (state["viz_mode"] - 1) % n_modes
        elif ch == 27:  # Esc
            if state["focus"] == "right":
                state["focus"] = "left"
                state["detail_scroll"] = 0
            else:
                state["selected"] = -1
        elif ch in (ord("j"), curses.KEY_DOWN):
            if state["focus"] == "right":
                viz_m = VIZ_MODES[state.get("viz_mode", 0) % len(VIZ_MODES)] if state.get("viz_mode", 0) < len(VIZ_MODES) else ""
                if viz_m == "graph" and state.get("graph_nodes"):
                    state["graph_hover"] = min(state.get("graph_hover", 0) + 1, len(state["graph_nodes"]) - 1)
                else:
                    state["detail_scroll"] = state.get("detail_scroll", 0) + 1
            else:
                agents = state["visible_items"]
                if agents:
                    state["selected"] = min(state["selected"] + 1, len(agents) - 1) if state["selected"] >= 0 else 0
        elif ch in (ord("k"), curses.KEY_UP):
            if state["focus"] == "right":
                viz_m = VIZ_MODES[state.get("viz_mode", 0) % len(VIZ_MODES)] if state.get("viz_mode", 0) < len(VIZ_MODES) else ""
                if viz_m == "graph" and state.get("graph_nodes"):
                    state["graph_hover"] = max(0, state.get("graph_hover", 0) - 1)
                else:
                    state["detail_scroll"] = max(0, state.get("detail_scroll", 0) - 1)
            elif state["selected"] > 0:
                state["selected"] -= 1
        elif ch in (ord("l"), curses.KEY_RIGHT):
            # Graph mode: move to next sibling at same layer
            viz_m = VIZ_MODES[state.get("viz_mode", 0) % len(VIZ_MODES)] if state.get("viz_mode", 0) < len(VIZ_MODES) else ""
            gn = state.get("graph_nodes", [])
            if state["focus"] == "right" and viz_m == "graph" and gn:
                gh = state.get("graph_hover", 0)
                cur_layer = gn[gh]["layer"] if gh < len(gn) else -1
                for i in range(gh + 1, len(gn)):
                    if gn[i]["layer"] == cur_layer:
                        state["graph_hover"] = i
                        break
                    elif gn[i]["layer"] != cur_layer:
                        break  # passed this layer
            else:
                sel = state["selected"]
                items = state["visible_items"]
                sel_is_stat = 0 <= sel < len(items) and items[sel].get("is_stat")
                if state["focus"] == "left" and sel >= 0 and not sel_is_stat:
                    state["focus"] = "right"
                    state["detail_scroll"] = 0
                    state["graph_hover"] = 0
                else:
                    old = state["stats_range"]
                    state["stats_range"] = min(old + 1, len(STATS_RANGES) - 1)
                    if state["stats_range"] != old:
                        refresh_data(cache, state["stats_range"])
        elif ch in (ord("h"), curses.KEY_LEFT):
            viz_m = VIZ_MODES[state.get("viz_mode", 0) % len(VIZ_MODES)] if state.get("viz_mode", 0) < len(VIZ_MODES) else ""
            gn = state.get("graph_nodes", [])
            if state["focus"] == "right" and viz_m == "graph" and gn:
                gh = state.get("graph_hover", 0)
                cur_layer = gn[gh]["layer"] if gh < len(gn) else -1
                for i in range(gh - 1, -1, -1):
                    if gn[i]["layer"] == cur_layer:
                        state["graph_hover"] = i
                        break
                    elif gn[i]["layer"] != cur_layer:
                        break  # passed this layer
            elif state["focus"] == "right":
                state["focus"] = "left"
                state["detail_scroll"] = 0
            else:
                old = state["stats_range"]
                state["stats_range"] = max(old - 1, 0)
                if state["stats_range"] != old:
                    refresh_data(cache, state["stats_range"])
        elif ch in (10, 13, curses.KEY_ENTER):
            if state["focus"] == "left" and state["selected"] >= 0:
                # Enter focuses detail panel
                state["focus"] = "right"
                state["detail_scroll"] = 0
            elif state["focus"] == "right":
                # Enter on detail opens agent transcript
                idx = state["selected"]
                agents = state["visible_items"]
                if 0 <= idx < len(agents):
                    item = agents[idx]
                    is_agent = not item.get("is_session") and not item.get("is_teammate")
                    is_history_agent = item.get("is_history") and item.get("kind") == "agent"
                    if is_agent or is_history_agent:
                        short = item["agent_id"][:7]
                        try:
                            err = open_agent_in_iterm2(item)
                            atype = (item.get("agent_type") or "agent")[:12]
                            state["status_msg"] = err if err else f"opened tab: {atype}-{short}"
                        except Exception as e:
                            state["status_msg"] = str(e)[:40]
                        state["status_until"] = time.time() + 3


def self_update():
    """Pull latest from GitHub and replace the running script."""
    import urllib.request
    raw_url = "https://raw.githubusercontent.com/kingsotn-twelve/agent-top/main/agent-top"
    try:
        with urllib.request.urlopen(raw_url, timeout=10) as resp:
            new_src = resp.read().decode()
    except Exception as e:
        print(f"update failed: {e}")
        sys.exit(1)
    # Extract remote version
    remote_ver = None
    for line in new_src.splitlines()[:30]:
        if line.startswith("VERSION"):
            remote_ver = line.split('"')[1]
            break
    if remote_ver == VERSION:
        print(f"already up to date (v{VERSION})")
        return
    # Overwrite self
    me = os.path.realpath(sys.argv[0])
    try:
        with open(me, "w") as f:
            f.write(new_src)
        print(f"updated v{VERSION} → v{remote_ver}")
    except Exception as e:
        print(f"write failed: {e}")
        sys.exit(1)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog="agent-top",
        description="Live terminal dashboard for Claude Code sessions & agents.\n"
                    "Tree view: agents nested under sessions, tool feed for agentless sessions.\n"
                    "Run in a separate pane alongside Claude Code.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "--version", action="version", version=f"agent-top v{VERSION}"
    )
    parser.add_argument(
        "--update", action="store_true", help="self-update from GitHub"
    )
    parser.add_argument(
        "--game-of-life", action="store_true", help="show Conway's Game of Life"
    )
    args = parser.parse_args()

    if args.update:
        self_update()
        sys.exit(0)

    try:
        curses.wrapper(lambda stdscr: main(stdscr, game_of_life=args.game_of_life))
    except KeyboardInterrupt:
        pass
